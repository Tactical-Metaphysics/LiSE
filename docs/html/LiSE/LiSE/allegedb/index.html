
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>allegedb &#8212; LiSE 0.9dev documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="prev" title="ELiDE" href="../../../ELiDE/index.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="allegedb">
<h1>allegedb<a class="headerlink" href="#allegedb" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<p>State container and object-relational mapper for versioned graphs.</p>
<p>allegedb serves its own special variant on the networkx
DiGraph class (with more to come). Every change to them is
stored in an SQL database.</p>
<p>This means you can keep multiple versions of one set of graphs and
switch between them without the need to save, load, or run git-checkout.
Just point the ORM at the correct branch and turn, and all of the
graphs in the program will change. All the different branches and
revisions remain in the database to be brought back when needed.</p>
<div class="section" id="usage">
<h2>usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">LiSE.allegedb</span> <span class="kn">import</span> <span class="n">ORM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orm</span> <span class="o">=</span> <span class="n">ORM</span><span class="p">(</span><span class="s1">&#39;sqlite:///test.db&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">orm</span><span class="o">.</span><span class="n">new_digraph</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;ham&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">adj</span>
<span class="go">&lt;LiSE.allegedb.graph.DiGraphSuccessorsMapping object containing {&#39;ham&#39;: {}, &#39;eggs&#39;: {}, &#39;spam&#39;: {&#39;eggs&#39;: {}}}&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">g</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orm</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">orm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orm</span> <span class="o">=</span> <span class="n">ORM</span><span class="p">(</span><span class="s1">&#39;sqlite:///test.db&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">orm</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">adj</span>
<span class="go">&lt;LiSE.allegedb.graph.DiGraphSuccessorsMapping object containing {&#39;ham&#39;: {}, &#39;eggs&#39;: {}, &#39;spam&#39;: {&#39;eggs&#39;: {}}}&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">random_lobster</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blue</span> <span class="o">=</span> <span class="n">orm</span><span class="o">.</span><span class="n">new_digraph</span><span class="p">(</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">red</span><span class="p">)</span>  <span class="c1"># initialize with data from the given graph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red</span><span class="o">.</span><span class="n">adj</span> <span class="o">==</span> <span class="n">blue</span><span class="o">.</span><span class="n">adj</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orm</span><span class="o">.</span><span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blue</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red</span><span class="o">.</span><span class="n">adj</span> <span class="o">==</span> <span class="n">blue</span><span class="o">.</span><span class="n">adj</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orm</span><span class="o">.</span><span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># undoing what I did when turn=1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red</span><span class="o">.</span><span class="n">adj</span> <span class="o">==</span> <span class="n">blue</span><span class="o">.</span><span class="n">adj</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orm</span><span class="o">.</span><span class="n">branch</span> <span class="o">=</span> <span class="s1">&#39;test&#39;</span>    <span class="c1"># navigating to a branch for the first time creates that branch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orm</span><span class="o">.</span><span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red</span><span class="o">.</span><span class="n">adj</span> <span class="o">==</span> <span class="n">blue</span><span class="o">.</span><span class="n">adj</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orm</span><span class="o">.</span><span class="n">branch</span> <span class="o">=</span> <span class="s1">&#39;trunk&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red</span><span class="o">.</span><span class="n">adj</span> <span class="o">==</span> <span class="n">blue</span><span class="o">.</span><span class="n">adj</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="module-LiSE.allegedb">
<span id="orm"></span><h2>ORM<a class="headerlink" href="#module-LiSE.allegedb" title="Permalink to this headline">¶</a></h2>
<p>The main interface to the allegedb ORM, and some supporting functions and classes</p>
<dl class="py exception">
<dt id="LiSE.allegedb.GraphNameError">
<em class="property">exception </em><code class="sig-prename descclassname">LiSE.allegedb.</code><code class="sig-name descname">GraphNameError</code><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#GraphNameError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.GraphNameError" title="Permalink to this definition">¶</a></dt>
<dd><p>For errors involving graphs’ names</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.ORM">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.</code><code class="sig-name descname">ORM</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dbstring</span></em>, <em class="sig-param"><span class="n">alchemy</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">connect_args</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">validate</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate this with the same string argument you’d use for a
SQLAlchemy <code class="docutils literal notranslate"><span class="pre">create_engine</span></code> call. This will be your interface to
allegedb.</p>
<dl class="py method">
<dt id="LiSE.allegedb.ORM.advancing">
<code class="sig-name descname">advancing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.advancing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.advancing" title="Permalink to this definition">¶</a></dt>
<dd><p>A context manager for when time is moving forward one turn at a time.</p>
<p>When used in LiSE, this means that the game is being simulated.
It changes how the caching works, making it more efficient.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.batch">
<code class="sig-name descname">batch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.batch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.batch" title="Permalink to this definition">¶</a></dt>
<dd><p>A context manager for when you’re creating lots of state.</p>
<p>Reads will be much slower in a batch, but writes will be faster.</p>
<p>You <em>can</em> combine this with <code class="docutils literal notranslate"><span class="pre">advancing</span></code> but it isn’t any faster.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Write changes to database and close the connection</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.commit">
<code class="sig-name descname">commit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.commit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the state of all graphs to the database and commit the transaction.</p>
<p>Also saves the current branch, turn, and tick.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.del_graph">
<code class="sig-name descname">del_graph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.del_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.del_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all traces of a graph’s existence from the database</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> – name of an existing graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.delete_plan">
<code class="sig-name descname">delete_plan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">plan</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.delete_plan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.delete_plan" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the portion of a plan that has yet to occur.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>plan</strong> – integer ID of a plan, as given by <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">self.plan()</span> <span class="pre">as</span> <span class="pre">plan:</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.ORM.edge_cls">
<code class="sig-name descname">edge_cls</code><a class="headerlink" href="#LiSE.allegedb.ORM.edge_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.allegedb.graph.Edge" title="LiSE.allegedb.graph.Edge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.allegedb.graph.Edge</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.get_delta">
<code class="sig-name descname">get_delta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn_from</span></em>, <em class="sig-param"><span class="n">tick_from</span></em>, <em class="sig-param"><span class="n">turn_to</span></em>, <em class="sig-param"><span class="n">tick_to</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.get_delta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.get_delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary describing changes to all graphs.</p>
<p>The keys are graph names. Their values are dictionaries of the graphs’
attributes’ new values, with <code class="docutils literal notranslate"><span class="pre">None</span></code> for deleted keys. Also in those graph
dictionaries are special keys ‘node_val’ and ‘edge_val’ describing changes
to node and edge attributes, and ‘nodes’ and ‘edges’ full of booleans
indicating whether a node or edge exists.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.get_graph">
<code class="sig-name descname">get_graph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.get_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.get_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a graph previously created with <code class="docutils literal notranslate"><span class="pre">new_graph</span></code>,
<code class="docutils literal notranslate"><span class="pre">new_digraph</span></code>, <code class="docutils literal notranslate"><span class="pre">new_multigraph</span></code>, or
<code class="docutils literal notranslate"><span class="pre">new_multidigraph</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> – name of an existing graph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.get_turn_delta">
<code class="sig-name descname">get_turn_delta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">branch</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">turn</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tick_from</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">tick_to</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.get_turn_delta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.get_turn_delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary describing changes made on a given turn.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">tick_to</span></code> is not supplied, report all changes after <code class="docutils literal notranslate"><span class="pre">tick_from</span></code>
(default 0).</p>
<p>The keys are graph names. Their values are dictionaries of the graphs’
attributes’ new values, with <code class="docutils literal notranslate"><span class="pre">None</span></code> for deleted keys. Also in those graph
dictionaries are special keys ‘node_val’ and ‘edge_val’ describing changes
to node and edge attributes, and ‘nodes’ and ‘edges’ full of booleans
indicating whether a node or edge exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>branch</strong> – A branch of history; defaults to the current branch</p></li>
<li><p><strong>turn</strong> – The turn in the branch; defaults to the current turn</p></li>
<li><p><strong>tick_from</strong> – Starting tick; defaults to 0</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.is_parent_of">
<code class="sig-name descname">is_parent_of</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parent</span></em>, <em class="sig-param"><span class="n">child</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.is_parent_of"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.is_parent_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <code class="docutils literal notranslate"><span class="pre">child</span></code> is a branch descended from <code class="docutils literal notranslate"><span class="pre">parent</span></code> at
any remove.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.new_digraph">
<code class="sig-name descname">new_digraph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.new_digraph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.new_digraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of type DiGraph, initialized with the given
data if provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – a name for the graph</p></li>
<li><p><strong>data</strong> – dictionary or NetworkX graph object providing initial state</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.new_graph">
<code class="sig-name descname">new_graph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.new_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.new_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of type Graph, initialized with the given
data if provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – a name for the graph</p></li>
<li><p><strong>data</strong> – dictionary or NetworkX graph object providing initial state</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.new_multidigraph">
<code class="sig-name descname">new_multidigraph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.new_multidigraph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.new_multidigraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of type MultiDiGraph, initialized with the given
data if provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – a name for the graph</p></li>
<li><p><strong>data</strong> – dictionary or NetworkX graph object providing initial state</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.new_multigraph">
<code class="sig-name descname">new_multigraph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.new_multigraph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.new_multigraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of type MultiGraph, initialized with the given
data if provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – a name for the graph</p></li>
<li><p><strong>data</strong> – dictionary or NetworkX graph object providing initial state</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.ORM.node_cls">
<code class="sig-name descname">node_cls</code><a class="headerlink" href="#LiSE.allegedb.ORM.node_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.allegedb.graph.Node" title="LiSE.allegedb.graph.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.allegedb.graph.Node</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.ORM.plan">
<code class="sig-name descname">plan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#ORM.plan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.ORM.plan" title="Permalink to this definition">¶</a></dt>
<dd><p>A context manager for ‘hypothetical’ edits.</p>
<p>Start a block of code like:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>`
with orm.plan():</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p><a href="#id3"><span class="problematic" id="id4">``</span></a><a href="#id5"><span class="problematic" id="id6">`</span></a></p>
<p>and any changes you make to the world state within that block will be
‘plans,’ meaning that they are used as defaults. The world will
obey your plan unless you make changes to the same entities outside
of the plan, in which case the world will obey those, and cancel any
future plan.</p>
<p>New branches cannot be started within plans. The <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">orm.forward():</span></code>
optimization is disabled within a <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">orm.plan():</span></code> block, so
consider another approach instead of making a very large plan.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.ORM.query_engine_cls">
<code class="sig-name descname">query_engine_cls</code><a class="headerlink" href="#LiSE.allegedb.ORM.query_engine_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.allegedb.query.QueryEngine" title="LiSE.allegedb.query.QueryEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.allegedb.query.QueryEngine</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.PlanningContext">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.</code><code class="sig-name descname">PlanningContext</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orm</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#PlanningContext"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.PlanningContext" title="Permalink to this definition">¶</a></dt>
<dd><p>A context manager for ‘hypothetical’ edits.</p>
<p>Start a block of code like:</p>
<p><a href="#id7"><span class="problematic" id="id8">``</span></a>`
with orm.plan():</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a></p>
<p>and any changes you make to the world state within that block will be
‘plans,’ meaning that they are used as defaults. The world will
obey your plan unless you make changes to the same entities outside
of the plan, in which case the world will obey those, and cancel any
future plan.</p>
<p>New branches cannot be started within plans. The <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">orm.forward():</span></code>
optimization is disabled within a <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">orm.plan():</span></code> block, so
consider another approach instead of making a very large plan.</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.TimeSignal">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.</code><code class="sig-name descname">TimeSignal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">engine</span></em>, <em class="sig-param"><span class="n">sig</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#TimeSignal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.TimeSignal" title="Permalink to this definition">¶</a></dt>
<dd><p>Acts like a tuple of <code class="docutils literal notranslate"><span class="pre">(branch,</span> <span class="pre">turn)</span></code> for the most part.</p>
<p>This wraps a <code class="docutils literal notranslate"><span class="pre">Signal</span></code>. To set a function to be called whenever the branch
or turn changes, pass it to my <code class="docutils literal notranslate"><span class="pre">connect</span></code> method.</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.TimeSignalDescriptor">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.</code><code class="sig-name descname">TimeSignalDescriptor</code><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#TimeSignalDescriptor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.TimeSignalDescriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Acts like a tuple of <code class="docutils literal notranslate"><span class="pre">(branch,</span> <span class="pre">turn)</span></code> for the most part.</p>
<p>This wraps a <code class="docutils literal notranslate"><span class="pre">Signal</span></code>. To set a function to be called whenever the branch
or turn changes, pass it to my <code class="docutils literal notranslate"><span class="pre">connect</span></code> method.</p>
</dd></dl>

<dl class="py function">
<dt id="LiSE.allegedb.setedge">
<code class="sig-prename descclassname">LiSE.allegedb.</code><code class="sig-name descname">setedge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">delta</span></em>, <em class="sig-param"><span class="n">is_multigraph</span></em>, <em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">exists</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#setedge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.setedge" title="Permalink to this definition">¶</a></dt>
<dd><p>Change a delta to say that an edge was created or deleted</p>
</dd></dl>

<dl class="py function">
<dt id="LiSE.allegedb.setedgeval">
<code class="sig-prename descclassname">LiSE.allegedb.</code><code class="sig-name descname">setedgeval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">delta</span></em>, <em class="sig-param"><span class="n">is_multigraph</span></em>, <em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#setedgeval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.setedgeval" title="Permalink to this definition">¶</a></dt>
<dd><p>Change a delta to say that an edge stat was set to a certain value</p>
</dd></dl>

<dl class="py function">
<dt id="LiSE.allegedb.setgraphval">
<code class="sig-prename descclassname">LiSE.allegedb.</code><code class="sig-name descname">setgraphval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">delta</span></em>, <em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#setgraphval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.setgraphval" title="Permalink to this definition">¶</a></dt>
<dd><p>Change a delta to say that a graph stat was set to a certain value</p>
</dd></dl>

<dl class="py function">
<dt id="LiSE.allegedb.setnode">
<code class="sig-prename descclassname">LiSE.allegedb.</code><code class="sig-name descname">setnode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">delta</span></em>, <em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">exists</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#setnode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.setnode" title="Permalink to this definition">¶</a></dt>
<dd><p>Change a delta to say that a node was created or deleted</p>
</dd></dl>

<dl class="py function">
<dt id="LiSE.allegedb.setnodeval">
<code class="sig-prename descclassname">LiSE.allegedb.</code><code class="sig-name descname">setnodeval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">delta</span></em>, <em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb.html#setnodeval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.setnodeval" title="Permalink to this definition">¶</a></dt>
<dd><p>Change a delta to say that a node stat was set to a certain value</p>
</dd></dl>

</div>
<div class="section" id="module-LiSE.allegedb.cache">
<span id="cache"></span><h2>cache<a class="headerlink" href="#module-LiSE.allegedb.cache" title="Permalink to this headline">¶</a></h2>
<p>Classes for in-memory storage and retrieval of historical graph data.</p>
<dl class="py class">
<dt id="LiSE.allegedb.cache.Cache">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.cache.</code><code class="sig-name descname">Cache</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">db</span></em>, <em class="sig-param"><span class="n">kfkvs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#Cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.Cache" title="Permalink to this definition">¶</a></dt>
<dd><p>A data store that’s useful for tracking graph revisions.</p>
<dl class="py attribute">
<dt id="LiSE.allegedb.cache.Cache.branches">
<code class="sig-name descname">branches</code><a class="headerlink" href="#LiSE.allegedb.cache.Cache.branches" title="Permalink to this definition">¶</a></dt>
<dd><p>A less structured alternative to <code class="docutils literal notranslate"><span class="pre">keys</span></code>.</p>
<p>For when you already know the entity and the key within it,
but still need to iterate through history to find the value.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.contains_entity">
<code class="sig-name descname">contains_entity</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.allegedb.cache.Cache.contains_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an entity has a key at the given time, if entity specified.</p>
<p>Otherwise check if the entity exists.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.contains_entity_key">
<code class="sig-name descname">contains_entity_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.allegedb.cache.Cache.contains_entity_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an entity has a key at the given time, if entity specified.</p>
<p>Otherwise check if the entity exists.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.contains_entity_or_key">
<code class="sig-name descname">contains_entity_or_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#Cache.contains_entity_or_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.Cache.contains_entity_or_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an entity has a key at the given time, if entity specified.</p>
<p>Otherwise check if the entity exists.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.contains_key">
<code class="sig-name descname">contains_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.allegedb.cache.Cache.contains_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an entity has a key at the given time, if entity specified.</p>
<p>Otherwise check if the entity exists.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.count_entities">
<code class="sig-name descname">count_entities</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.allegedb.cache.Cache.count_entities" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of keys an entity has, if you specify an entity.</p>
<p>Otherwise return the number of entities.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.count_entities_or_keys">
<code class="sig-name descname">count_entities_or_keys</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#Cache.count_entities_or_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.Cache.count_entities_or_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of keys an entity has, if you specify an entity.</p>
<p>Otherwise return the number of entities.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.count_entity_keys">
<code class="sig-name descname">count_entity_keys</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.allegedb.cache.Cache.count_entity_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of keys an entity has, if you specify an entity.</p>
<p>Otherwise return the number of entities.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.count_keys">
<code class="sig-name descname">count_keys</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.allegedb.cache.Cache.count_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of keys an entity has, if you specify an entity.</p>
<p>Otherwise return the number of entities.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.iter_entities">
<code class="sig-name descname">iter_entities</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.allegedb.cache.Cache.iter_entities" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the keys an entity has, if you specify an entity.</p>
<p>Otherwise iterate over the entities themselves, or at any rate the
tuple specifying which entity.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.iter_entities_or_keys">
<code class="sig-name descname">iter_entities_or_keys</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#Cache.iter_entities_or_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.Cache.iter_entities_or_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the keys an entity has, if you specify an entity.</p>
<p>Otherwise iterate over the entities themselves, or at any rate the
tuple specifying which entity.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.iter_entity_keys">
<code class="sig-name descname">iter_entity_keys</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.allegedb.cache.Cache.iter_entity_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the keys an entity has, if you specify an entity.</p>
<p>Otherwise iterate over the entities themselves, or at any rate the
tuple specifying which entity.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.iter_keys">
<code class="sig-name descname">iter_keys</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.allegedb.cache.Cache.iter_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the keys an entity has, if you specify an entity.</p>
<p>Otherwise iterate over the entities themselves, or at any rate the
tuple specifying which entity.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.cache.Cache.keycache">
<code class="sig-name descname">keycache</code><a class="headerlink" href="#LiSE.allegedb.cache.Cache.keycache" title="Permalink to this definition">¶</a></dt>
<dd><p>Keys an entity has at a given turn and tick.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.cache.Cache.keyframe">
<code class="sig-name descname">keyframe</code><a class="headerlink" href="#LiSE.allegedb.cache.Cache.keyframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Key-value dictionaries representing my state at a given time</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.cache.Cache.keys">
<code class="sig-name descname">keys</code><a class="headerlink" href="#LiSE.allegedb.cache.Cache.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Cache of entity data keyed by the entities themselves.</p>
<p>That means the whole tuple identifying the entity is the
top-level key in this cache here. The second-to-top level
is the key within the entity.</p>
<p>Deeper layers of this cache are keyed by branch, turn, and tick.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.load">
<code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#Cache.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.Cache.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a bunch of data. Must be in chronological order.</p>
<p>But it doesn’t need to all be from the same branch, as long as
each branch is chronological of itself.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.cache.Cache.parents">
<code class="sig-name descname">parents</code><a class="headerlink" href="#LiSE.allegedb.cache.Cache.parents" title="Permalink to this definition">¶</a></dt>
<dd><p>Entity data keyed by the entities’ parents.</p>
<p>An entity’s parent is what it’s contained in. When speaking of a node,
this is its graph. When speaking of an edge, the parent is usually the
graph and the origin in a pair, though for multigraphs the destination
might be part of the parent as well.</p>
<p>Deeper layers of this cache are keyed by branch and revision.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.cache.Cache.presettings">
<code class="sig-name descname">presettings</code><a class="headerlink" href="#LiSE.allegedb.cache.Cache.presettings" title="Permalink to this definition">¶</a></dt>
<dd><p>The values prior to <code class="docutils literal notranslate"><span class="pre">entity[key]</span> <span class="pre">=</span> <span class="pre">value</span></code> operations performed on some turn</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.remove">
<code class="sig-name descname">remove</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#Cache.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.Cache.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete all data from a specific tick</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.retrieve">
<code class="sig-name descname">retrieve</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#Cache.retrieve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.Cache.retrieve" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a value previously .store(…)’d.</p>
<p>Needs at least five arguments. The -1th is the tick
within the turn you want,
the -2th is that turn, the -3th is the branch,
and the -4th is the key. All other arguments identify
the entity that the key is in.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.cache.Cache.settings">
<code class="sig-name descname">settings</code><a class="headerlink" href="#LiSE.allegedb.cache.Cache.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>All the <code class="docutils literal notranslate"><span class="pre">entity[key]</span> <span class="pre">=</span> <span class="pre">value</span></code> operations that were performed on some turn</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.cache.Cache.shallowest">
<code class="sig-name descname">shallowest</code><a class="headerlink" href="#LiSE.allegedb.cache.Cache.shallowest" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary for plain, unstructured hinting.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.store">
<code class="sig-name descname">store</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">planning</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">loading</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">contra</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#Cache.store"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.Cache.store" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a value in various dictionaries for later .retrieve(…).</p>
<p>Needs at least five arguments, of which the -1th is the value
to store, the -2th is the tick to store it at, the -3th
is the turn to store it in, the -4th is the branch the
revision is in, the -5th is the key the value is for,
and the remaining arguments identify the entity that has
the key, eg. a graph, node, or edge.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">planning=True</span></code>, you will be permitted to alter
“history” that takes place after the last non-planning
moment of time, without much regard to consistency.
Otherwise, contradictions will be handled by deleting
everything in the contradicted plan after the present moment,
unless you set <code class="docutils literal notranslate"><span class="pre">contra=False</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">loading=True</span></code> prevents me from updating the ORM’s records
of the ends of branches and turns.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.Cache.truncate">
<code class="sig-name descname">truncate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#Cache.truncate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.Cache.truncate" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete all data after (not on) a specific tick</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.cache.EdgesCache">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.cache.</code><code class="sig-name descname">EdgesCache</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">db</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#EdgesCache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.EdgesCache" title="Permalink to this definition">¶</a></dt>
<dd><p>A cache for remembering whether edges exist at a given time.</p>
<dl class="py method">
<dt id="LiSE.allegedb.cache.EdgesCache.count_predecessors">
<code class="sig-name descname">count_predecessors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#EdgesCache.count_predecessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.EdgesCache.count_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of predecessors from a given destination node at a given time.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.EdgesCache.count_successors">
<code class="sig-name descname">count_successors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#EdgesCache.count_successors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.EdgesCache.count_successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of successors to a given origin node at a given time.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.EdgesCache.has_predecessor">
<code class="sig-name descname">has_predecessor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#EdgesCache.has_predecessor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.EdgesCache.has_predecessor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether an edge connects the destination to the origin at the given time.</p>
<p>Doesn’t require the edge’s index, which makes it slower than retrieving a
particular edge.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.EdgesCache.has_successor">
<code class="sig-name descname">has_successor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#EdgesCache.has_successor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.EdgesCache.has_successor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether an edge connects the origin to the destination at the given time.</p>
<p>Doesn’t require the edge’s index, which makes it slower than retrieving a
particular edge.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.EdgesCache.iter_predecessors">
<code class="sig-name descname">iter_predecessors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#EdgesCache.iter_predecessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.EdgesCache.iter_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over predecessors to a given destination node at a given time.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.EdgesCache.iter_successors">
<code class="sig-name descname">iter_successors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#EdgesCache.iter_successors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.EdgesCache.iter_successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over successors of a given origin node at a given time.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.cache.EdgesCache.store">
<code class="sig-name descname">store</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">ex</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">planning</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">loading</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">contra</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#EdgesCache.store"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.EdgesCache.store" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a value in various dictionaries for later .retrieve(…).</p>
<p>Needs at least five arguments, of which the -1th is the value
to store, the -2th is the tick to store it at, the -3th
is the turn to store it in, the -4th is the branch the
revision is in, the -5th is the key the value is for,
and the remaining arguments identify the entity that has
the key, eg. a graph, node, or edge.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">planning=True</span></code>, you will be permitted to alter
“history” that takes place after the last non-planning
moment of time, without much regard to consistency.
Otherwise, contradictions will be handled by deleting
everything in the contradicted plan after the present moment,
unless you set <code class="docutils literal notranslate"><span class="pre">contra=False</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">loading=True</span></code> prevents me from updating the ORM’s records
of the ends of branches and turns.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.cache.NodesCache">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.cache.</code><code class="sig-name descname">NodesCache</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">db</span></em>, <em class="sig-param"><span class="n">kfkvs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#NodesCache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.NodesCache" title="Permalink to this definition">¶</a></dt>
<dd><p>A cache for remembering whether nodes exist at a given time.</p>
<dl class="py method">
<dt id="LiSE.allegedb.cache.NodesCache.store">
<code class="sig-name descname">store</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">ex</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">planning</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">forward</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">loading</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">contra</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#NodesCache.store"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.NodesCache.store" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a value in various dictionaries for later .retrieve(…).</p>
<p>Needs at least five arguments, of which the -1th is the value
to store, the -2th is the tick to store it at, the -3th
is the turn to store it in, the -4th is the branch the
revision is in, the -5th is the key the value is for,
and the remaining arguments identify the entity that has
the key, eg. a graph, node, or edge.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">planning=True</span></code>, you will be permitted to alter
“history” that takes place after the last non-planning
moment of time, without much regard to consistency.
Otherwise, contradictions will be handled by deleting
everything in the contradicted plan after the present moment,
unless you set <code class="docutils literal notranslate"><span class="pre">contra=False</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">loading=True</span></code> prevents me from updating the ORM’s records
of the ends of branches and turns.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.cache.PickyDefaultDict">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.cache.</code><code class="sig-name descname">PickyDefaultDict</code><span class="sig-paren">(</span><em class="sig-param">type=&lt;class 'object'&gt;</em>, <em class="sig-param">args_munger=&lt;function _default_args_munger&gt;</em>, <em class="sig-param">kwargs_munger=&lt;function _default_kwargs_munger&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#PickyDefaultDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.PickyDefaultDict" title="Permalink to this definition">¶</a></dt>
<dd><p>A <code class="docutils literal notranslate"><span class="pre">defaultdict</span></code> alternative that requires values of a specific type.</p>
<p>Pass some type object (such as a class) to the constructor to
specify what type to use by default, which is the only type I will
accept.</p>
<p>Default values are constructed with no arguments by default;
supply <code class="docutils literal notranslate"><span class="pre">args_munger</span></code> and/or <code class="docutils literal notranslate"><span class="pre">kwargs_munger</span></code> to override this.
They take arguments <code class="docutils literal notranslate"><span class="pre">self</span></code> and the unused key being looked up.</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.cache.StructuredDefaultDict">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.cache.</code><code class="sig-name descname">StructuredDefaultDict</code><span class="sig-paren">(</span><em class="sig-param">layers</em>, <em class="sig-param">type=&lt;class 'object'&gt;</em>, <em class="sig-param">args_munger=&lt;function _default_args_munger&gt;</em>, <em class="sig-param">kwargs_munger=&lt;function _default_kwargs_munger&gt;</em>, <em class="sig-param">gettest=&lt;function StructuredDefaultDict.&lt;lambda&gt;&gt;</em>, <em class="sig-param">settest=&lt;function StructuredDefaultDict.&lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#StructuredDefaultDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.StructuredDefaultDict" title="Permalink to this definition">¶</a></dt>
<dd><p>A <code class="docutils literal notranslate"><span class="pre">defaultdict</span></code>-like class that expects values stored at a specific depth.</p>
<p>Requires an integer to tell it how many layers deep to go.
The innermost layer will be <code class="docutils literal notranslate"><span class="pre">PickyDefaultDict</span></code>, which will take the
<code class="docutils literal notranslate"><span class="pre">type</span></code>, <code class="docutils literal notranslate"><span class="pre">args_munger</span></code>, and <code class="docutils literal notranslate"><span class="pre">kwargs_munger</span></code> arguments supplied
to my constructor.</p>
</dd></dl>

<dl class="py function">
<dt id="LiSE.allegedb.cache.lru_append">
<code class="sig-prename descclassname">LiSE.allegedb.cache.</code><code class="sig-name descname">lru_append</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kc</span></em>, <em class="sig-param"><span class="n">lru</span></em>, <em class="sig-param"><span class="n">kckey</span></em>, <em class="sig-param"><span class="n">maxsize</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/cache.html#lru_append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.cache.lru_append" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete old data from <code class="docutils literal notranslate"><span class="pre">kc</span></code>, then add new <code class="docutils literal notranslate"><span class="pre">kckey</span></code> to <code class="docutils literal notranslate"><span class="pre">lru</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kc</strong> – a three-layer keycache</p></li>
<li><p><strong>lru</strong> – an <code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code> with a key for each triple that should fill out <code class="docutils literal notranslate"><span class="pre">kc</span></code>’s three layers</p></li>
<li><p><strong>kckey</strong> – a triple that indexes into <code class="docutils literal notranslate"><span class="pre">kc</span></code>, which will be added to <code class="docutils literal notranslate"><span class="pre">lru</span></code> if needed</p></li>
<li><p><strong>maxsize</strong> – maximum number of entries in <code class="docutils literal notranslate"><span class="pre">lru</span></code> and, therefore, <code class="docutils literal notranslate"><span class="pre">kc</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-LiSE.allegedb.graph">
<span id="graph"></span><h2>graph<a class="headerlink" href="#module-LiSE.allegedb.graph" title="Permalink to this headline">¶</a></h2>
<p>allegedb’s special implementations of the NetworkX graph objects</p>
<dl class="py class">
<dt id="LiSE.allegedb.graph.AbstractEntityMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">AbstractEntityMapping</code><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#AbstractEntityMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.AbstractEntityMapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.graph.AbstractSuccessors">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">AbstractSuccessors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">orig</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#AbstractSuccessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.AbstractSuccessors" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="LiSE.allegedb.graph.AbstractSuccessors.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#AbstractSuccessors.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.AbstractSuccessors.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete every edge with origin at my orig</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.AbstractSuccessors.db">
<em class="property">property </em><code class="sig-name descname">db</code><a class="headerlink" href="#LiSE.allegedb.graph.AbstractSuccessors.db" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias to <code class="docutils literal notranslate"><span class="pre">self.graph.db</span></code></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.graph.AllegedMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">AllegedMapping</code><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#AllegedMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.AllegedMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Common amenities for mappings</p>
<dl class="py method">
<dt id="LiSE.allegedb.graph.AllegedMapping.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#AllegedMapping.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.AllegedMapping.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete everything</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.AllegedMapping.connect">
<code class="sig-name descname">connect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#AllegedMapping.connect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.AllegedMapping.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Arrange to call this function whenever something changes here.</p>
<p>The arguments will be this object, the key changed, and the value set.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.AllegedMapping.disconnect">
<code class="sig-name descname">disconnect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#AllegedMapping.disconnect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.AllegedMapping.disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>No longer call the function when something changes here.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.AllegedMapping.send">
<code class="sig-name descname">send</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sender</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#AllegedMapping.send"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.AllegedMapping.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal. Call connected functions.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.graph.DiGraph">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">DiGraph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">db</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#DiGraph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of the networkx.DiGraph class that stores its state in a
database.</p>
<dl class="py method">
<dt id="LiSE.allegedb.graph.DiGraph.add_edge">
<code class="sig-name descname">add_edge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">attr_dict</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#DiGraph.add_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Version of add_edge that only writes to the database once</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.DiGraph.add_edges_from">
<code class="sig-name descname">add_edges_from</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ebunch</span></em>, <em class="sig-param"><span class="n">attr_dict</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#DiGraph.add_edges_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.add_edges_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Version of add_edges_from that only writes to the database once</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.DiGraph.add_node">
<code class="sig-name descname">add_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node_for_adding</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#DiGraph.add_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.add_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single node <cite>node_for_adding</cite> and update node attributes.</p>
<dl class="simple">
<dt>node_for_adding<span class="classifier">node</span></dt><dd><p>A node can be any hashable Python object except None.</p>
</dd>
<dt>attr<span class="classifier">keyword arguments, optional</span></dt><dd><p>Set or change node attributes using key=value.</p>
</dd>
</dl>
<p>add_nodes_from</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>   <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K3</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">K3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Use keywords set/change node attributes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">UTM</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;13S&#39;</span><span class="p">,</span> <span class="mi">382871</span><span class="p">,</span> <span class="mi">3972649</span><span class="p">))</span>
</pre></div>
</div>
<p>A hashable object is one that can be used as a key in a Python
dictionary. This includes strings, numbers, tuples of strings
and numbers, etc.</p>
<p>On many platforms hashable items also include mutables such as
NetworkX Graphs, though one should be careful that the hash
doesn’t change on mutables.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.DiGraph.adj">
<em class="property">property </em><code class="sig-name descname">adj</code><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.adj" title="Permalink to this definition">¶</a></dt>
<dd><p>Graph adjacency object holding the neighbors of each node.</p>
<p>This object is a read-only dict-like structure with node keys
and neighbor-dict values.  The neighbor-dict is keyed by neighbor
to the edge-data-dict.  So <cite>G.adj[3][2][‘color’] = ‘blue’</cite> sets
the color of the edge <cite>(3, 2)</cite> to <cite>“blue”</cite>.</p>
<p>Iterating over G.adj behaves like a dict. Useful idioms include
<cite>for nbr, datadict in G.adj[n].items():</cite>.</p>
<p>The neighbor information is also provided by subscripting the graph.
So <cite>for nbr, foovalue in G[node].data(‘foo’, default=1):</cite> works.</p>
<p>For directed graphs, <cite>G.adj</cite> holds outgoing (successor) info.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.graph.DiGraph.adj_cls">
<code class="sig-name descname">adj_cls</code><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.adj_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.allegedb.graph.DiGraphSuccessorsMapping" title="LiSE.allegedb.graph.DiGraphSuccessorsMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraphSuccessorsMapping</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.DiGraph.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#DiGraph.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all nodes and edges from the graph.</p>
<p>Unlike the regular networkx implementation, this does <em>not</em>
remove the graph’s name. But all the other graph, node, and
edge attributes go away.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.DiGraph.edge">
<em class="property">property </em><code class="sig-name descname">edge</code><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Graph adjacency object holding the neighbors of each node.</p>
<p>This object is a read-only dict-like structure with node keys
and neighbor-dict values.  The neighbor-dict is keyed by neighbor
to the edge-data-dict.  So <cite>G.adj[3][2][‘color’] = ‘blue’</cite> sets
the color of the edge <cite>(3, 2)</cite> to <cite>“blue”</cite>.</p>
<p>Iterating over G.adj behaves like a dict. Useful idioms include
<cite>for nbr, datadict in G.adj[n].items():</cite>.</p>
<p>The neighbor information is also provided by subscripting the graph.
So <cite>for nbr, foovalue in G[node].data(‘foo’, default=1):</cite> works.</p>
<p>For directed graphs, <cite>G.adj</cite> holds outgoing (successor) info.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.graph.DiGraph.graph_map_cls">
<code class="sig-name descname">graph_map_cls</code><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.graph_map_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.allegedb.graph.GraphMapping" title="LiSE.allegedb.graph.GraphMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphMapping</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.DiGraph.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.name" title="Permalink to this definition">¶</a></dt>
<dd><p>String identifier of the graph.</p>
<p>This graph attribute appears in the attribute dict G.graph
keyed by the string <cite>“name”</cite>. as well as an attribute (technically
a property) <cite>G.name</cite>. This is entirely user controlled.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.graph.DiGraph.node_map_cls">
<code class="sig-name descname">node_map_cls</code><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.node_map_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.allegedb.graph.GraphNodeMapping" title="LiSE.allegedb.graph.GraphNodeMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphNodeMapping</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.DiGraph.pred">
<em class="property">property </em><code class="sig-name descname">pred</code><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.pred" title="Permalink to this definition">¶</a></dt>
<dd><p>Graph adjacency object holding the predecessors of each node.</p>
<p>This object is a read-only dict-like structure with node keys
and neighbor-dict values.  The neighbor-dict is keyed by neighbor
to the edge-data-dict.  So <cite>G.pred[2][3][‘color’] = ‘blue’</cite> sets
the color of the edge <cite>(3, 2)</cite> to <cite>“blue”</cite>.</p>
<p>Iterating over G.pred behaves like a dict. Useful idioms include
<cite>for nbr, datadict in G.pred[n].items():</cite>.  A data-view not provided
by dicts also exists: <cite>for nbr, foovalue in G.pred[node].data(‘foo’):</cite>
A default can be set via a <cite>default</cite> argument to the <cite>data</cite> method.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.allegedb.graph.DiGraph.pred_cls">
<code class="sig-name descname">pred_cls</code><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.pred_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.allegedb.graph.DiGraphPredecessorsMapping" title="LiSE.allegedb.graph.DiGraphPredecessorsMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiGraphPredecessorsMapping</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.DiGraph.remove_edge">
<code class="sig-name descname">remove_edge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">u</span></em>, <em class="sig-param"><span class="n">v</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#DiGraph.remove_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.remove_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Version of remove_edge that’s much like normal networkx but only
deletes once, since the database doesn’t keep separate adj and
succ mappings</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.DiGraph.remove_edges_from">
<code class="sig-name descname">remove_edges_from</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ebunch</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#DiGraph.remove_edges_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.remove_edges_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Version of remove_edges_from that’s much like normal networkx but only
deletes once, since the database doesn’t keep separate adj and
succ mappings</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.DiGraph.remove_node">
<code class="sig-name descname">remove_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#DiGraph.remove_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.remove_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove node n.</p>
<p>Removes the node n and all adjacent edges.
Attempting to remove a non-existent node will raise an exception.</p>
<dl class="simple">
<dt>n<span class="classifier">node</span></dt><dd><p>A node in the graph</p>
</dd>
</dl>
<dl class="simple">
<dt>NetworkXError</dt><dd><p>If n is not in the graph.</p>
</dd>
</dl>
<p>remove_nodes_from</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.DiGraph.succ">
<em class="property">property </em><code class="sig-name descname">succ</code><a class="headerlink" href="#LiSE.allegedb.graph.DiGraph.succ" title="Permalink to this definition">¶</a></dt>
<dd><p>Graph adjacency object holding the neighbors of each node.</p>
<p>This object is a read-only dict-like structure with node keys
and neighbor-dict values.  The neighbor-dict is keyed by neighbor
to the edge-data-dict.  So <cite>G.adj[3][2][‘color’] = ‘blue’</cite> sets
the color of the edge <cite>(3, 2)</cite> to <cite>“blue”</cite>.</p>
<p>Iterating over G.adj behaves like a dict. Useful idioms include
<cite>for nbr, datadict in G.adj[n].items():</cite>.</p>
<p>The neighbor information is also provided by subscripting the graph.
So <cite>for nbr, foovalue in G[node].data(‘foo’, default=1):</cite> works.</p>
<p>For directed graphs, <cite>G.adj</cite> holds outgoing (successor) info.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.graph.DiGraphPredecessorsMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">DiGraphPredecessorsMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#DiGraphPredecessorsMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.DiGraphPredecessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping for Predecessors instances, which map to Edges that end at
the dest provided to this</p>
<dl class="py class">
<dt id="LiSE.allegedb.graph.DiGraphPredecessorsMapping.Predecessors">
<em class="property">class </em><code class="sig-name descname">Predecessors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">dest</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#DiGraphPredecessorsMapping.Predecessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.DiGraphPredecessorsMapping.Predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of Edges that end at a particular node</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.graph.DiGraphSuccessorsMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">DiGraphSuccessorsMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#DiGraphSuccessorsMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.DiGraphSuccessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py class">
<dt id="LiSE.allegedb.graph.DiGraphSuccessorsMapping.Successors">
<em class="property">class </em><code class="sig-name descname">Successors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">orig</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#DiGraphSuccessorsMapping.Successors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.DiGraphSuccessorsMapping.Successors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.graph.Edge">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">Edge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">idx</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#Edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.Edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping for edge attributes</p>
</dd></dl>

<dl class="py exception">
<dt id="LiSE.allegedb.graph.EntityCollisionError">
<em class="property">exception </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">EntityCollisionError</code><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#EntityCollisionError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.EntityCollisionError" title="Permalink to this definition">¶</a></dt>
<dd><p>For when there’s a discrepancy between the kind of entity you’re creating and the one by the same name</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.graph.GraphEdgeMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">GraphEdgeMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#GraphEdgeMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.GraphEdgeMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides an adjacency mapping and possibly a predecessor mapping
for a graph.</p>
<dl class="py method">
<dt id="LiSE.allegedb.graph.GraphEdgeMapping.db">
<em class="property">property </em><code class="sig-name descname">db</code><a class="headerlink" href="#LiSE.allegedb.graph.GraphEdgeMapping.db" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias to <code class="docutils literal notranslate"><span class="pre">self.graph.db</span></code></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.graph.GraphMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">GraphMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#GraphMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.GraphMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping for graph attributes</p>
<dl class="py method">
<dt id="LiSE.allegedb.graph.GraphMapping.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#GraphMapping.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.GraphMapping.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete everything</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.graph.GraphMapping.unwrap">
<code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#GraphMapping.unwrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.GraphMapping.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of myself as a dict, and unwrap any wrapper objects in me.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.graph.GraphNodeMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">GraphNodeMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#GraphNodeMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.GraphNodeMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping for nodes in a graph</p>
<dl class="py method">
<dt id="LiSE.allegedb.graph.GraphNodeMapping.db">
<em class="property">property </em><code class="sig-name descname">db</code><a class="headerlink" href="#LiSE.allegedb.graph.GraphNodeMapping.db" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias to <code class="docutils literal notranslate"><span class="pre">self.graph.db</span></code></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.graph.GraphSuccessorsMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">GraphSuccessorsMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#GraphSuccessorsMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.GraphSuccessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping for Successors (itself a MutableMapping)</p>
<dl class="py class">
<dt id="LiSE.allegedb.graph.GraphSuccessorsMapping.Successors">
<em class="property">class </em><code class="sig-name descname">Successors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">orig</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#GraphSuccessorsMapping.Successors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.GraphSuccessorsMapping.Successors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.graph.Node">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">Node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#Node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping for node attributes</p>
</dd></dl>

<dl class="py function">
<dt id="LiSE.allegedb.graph.convert_to_networkx_graph">
<code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">convert_to_networkx_graph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">create_using</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">multigraph_input</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#convert_to_networkx_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.convert_to_networkx_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an AllegedGraph to the corresponding NetworkX graph type.</p>
</dd></dl>

<dl class="py function">
<dt id="LiSE.allegedb.graph.getatt">
<code class="sig-prename descclassname">LiSE.allegedb.graph.</code><code class="sig-name descname">getatt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attribute_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/graph.html#getatt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.graph.getatt" title="Permalink to this definition">¶</a></dt>
<dd><p>An easy way to make an alias</p>
</dd></dl>

</div>
<div class="section" id="module-LiSE.allegedb.query">
<span id="query"></span><h2>query<a class="headerlink" href="#module-LiSE.allegedb.query" title="Permalink to this headline">¶</a></h2>
<p>Wrapper to run SQL queries in a lightly abstracted way, such that
code that’s more to do with the queries than with the data per se
doesn’t pollute the other files so much.</p>
<dl class="py class">
<dt id="LiSE.allegedb.query.GlobalKeyValueStore">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.query.</code><code class="sig-name descname">GlobalKeyValueStore</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">qe</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#GlobalKeyValueStore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.GlobalKeyValueStore" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict-like object that keeps its contents in a table.</p>
<p>Mostly this is for holding the current branch and revision.</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.query.QueryEngine">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.query.</code><code class="sig-name descname">QueryEngine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dbstring</span></em>, <em class="sig-param"><span class="n">connect_args</span></em>, <em class="sig-param"><span class="n">alchemy</span></em>, <em class="sig-param"><span class="n">pack</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">unpack</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around either a DBAPI2.0 connection or an
Alchemist. Provides methods to run queries using either.</p>
<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.all_branches">
<code class="sig-name descname">all_branches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.all_branches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.all_branches" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all the branch data in tuples of (branch, parent,
parent_turn).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit the transaction, then close the connection</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.commit">
<code class="sig-name descname">commit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.commit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit the transaction</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.del_graph">
<code class="sig-name descname">del_graph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.del_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.del_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete all records to do with the graph</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.edge_val_dump">
<code class="sig-name descname">edge_val_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.edge_val_dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.edge_val_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield the entire contents of the edge_val table.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.edge_val_set">
<code class="sig-name descname">edge_val_set</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.edge_val_set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.edge_val_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this key of this edge to this value.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.edges_dump">
<code class="sig-name descname">edges_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.edges_dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.edges_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump the entire contents of the edges table.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.exist_edge">
<code class="sig-name descname">exist_edge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">extant</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.exist_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.exist_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare whether or not this edge exists.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.exist_node">
<code class="sig-name descname">exist_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">extant</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.exist_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.exist_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare that the node exists or doesn’t.</p>
<p>Inserts a new record or updates an old one, as needed.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.flush">
<code class="sig-name descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.flush"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Put all pending changes into the SQL transaction.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.global_del">
<code class="sig-name descname">global_del</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.global_del"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.global_del" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the global record for the key.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.global_get">
<code class="sig-name descname">global_get</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.global_get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.global_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value for the given key in the <code class="docutils literal notranslate"><span class="pre">globals</span></code> table.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.global_items">
<code class="sig-name descname">global_items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.global_items"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.global_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over (key, value) pairs in the <code class="docutils literal notranslate"><span class="pre">globals</span></code> table.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.global_set">
<code class="sig-name descname">global_set</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.global_set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.global_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">key</span></code> to <code class="docutils literal notranslate"><span class="pre">value</span></code> globally (not at any particular branch or
revision)</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.graph_type">
<code class="sig-name descname">graph_type</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.graph_type"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.graph_type" title="Permalink to this definition">¶</a></dt>
<dd><p>What type of graph is this?</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.graph_val_dump">
<code class="sig-name descname">graph_val_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.graph_val_dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.graph_val_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield the entire contents of the graph_val table.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.have_branch">
<code class="sig-name descname">have_branch</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">branch</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.have_branch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.have_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the branch thus named exists in the database.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.have_graph">
<code class="sig-name descname">have_graph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.have_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.have_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether I have a graph by this name.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.initdb">
<code class="sig-name descname">initdb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.initdb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.initdb" title="Permalink to this definition">¶</a></dt>
<dd><p>Create tables and indices as needed.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.new_branch">
<code class="sig-name descname">new_branch</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">parent</span></em>, <em class="sig-param"><span class="n">parent_turn</span></em>, <em class="sig-param"><span class="n">parent_tick</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.new_branch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.new_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare that the <code class="docutils literal notranslate"><span class="pre">branch</span></code> is descended from <code class="docutils literal notranslate"><span class="pre">parent</span></code> at
<code class="docutils literal notranslate"><span class="pre">parent_turn</span></code>, <code class="docutils literal notranslate"><span class="pre">parent_tick</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.new_graph">
<code class="sig-name descname">new_graph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">typ</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.new_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.new_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare a new graph by this name of this type.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.node_val_dump">
<code class="sig-name descname">node_val_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.node_val_dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.node_val_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield the entire contents of the node_val table.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.node_val_set">
<code class="sig-name descname">node_val_set</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.node_val_set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.node_val_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a key-value pair on a node at a specific branch and revision</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.nodes_dump">
<code class="sig-name descname">nodes_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.nodes_dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.nodes_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump the entire contents of the nodes table.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.sql">
<code class="sig-name descname">sql</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stringname</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.sql"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.sql" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for the various prewritten or compiled SQL calls.</p>
<p>First argument is the name of the query, either a key in
<code class="docutils literal notranslate"><span class="pre">sqlite.json</span></code> or a method name in
<code class="docutils literal notranslate"><span class="pre">allegedb.alchemy.Alchemist</span></code>. The rest of the arguments are
parameters to the query.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.query.QueryEngine.sqlmany">
<code class="sig-name descname">sqlmany</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stringname</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#QueryEngine.sqlmany"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.QueryEngine.sqlmany" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for executing many SQL calls on my connection.</p>
<p>First arg is the name of a query, either a key in the
precompiled JSON or a method name in
<code class="docutils literal notranslate"><span class="pre">allegedb.alchemy.Alchemist</span></code>. Remaining arguments should be
tuples of argument sequences to be passed to the query.</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt id="LiSE.allegedb.query.TimeError">
<em class="property">exception </em><code class="sig-prename descclassname">LiSE.allegedb.query.</code><code class="sig-name descname">TimeError</code><a class="reference internal" href="../../../_modules/LiSE/allegedb/query.html#TimeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.query.TimeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception class for problems with the time model</p>
</dd></dl>

</div>
<div class="section" id="module-LiSE.allegedb.wrap">
<span id="wrap"></span><h2>wrap<a class="headerlink" href="#module-LiSE.allegedb.wrap" title="Permalink to this headline">¶</a></h2>
<p>Wrapper classes to let you store mutable data types in the allegedb ORM</p>
<dl class="py class">
<dt id="LiSE.allegedb.wrap.DictWrapper">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.wrap.</code><code class="sig-name descname">DictWrapper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">getter</span></em>, <em class="sig-param"><span class="n">setter</span></em>, <em class="sig-param"><span class="n">outer</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#DictWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.DictWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary synchronized with a serialized field.</p>
<p>This is meant to be used in allegedb entities (graph, node, or
edge), for when the user stores a dictionary in them.</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.wrap.ListWrapper">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.wrap.</code><code class="sig-name descname">ListWrapper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">getter</span></em>, <em class="sig-param"><span class="n">setter</span></em>, <em class="sig-param"><span class="n">outer</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#ListWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.ListWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>A list synchronized with a serialized field.</p>
<p>This is meant to be used in allegedb entities (graph, node, or
edge), for when the user stores a list in them.</p>
<dl class="py method">
<dt id="LiSE.allegedb.wrap.ListWrapper.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#ListWrapper.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.ListWrapper.append" title="Permalink to this definition">¶</a></dt>
<dd><p>S.append(value) – append value to the end of the sequence</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.wrap.ListWrapper.insert">
<code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">v</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#ListWrapper.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.ListWrapper.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>S.insert(index, value) – insert value before index</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.wrap.ListWrapper.unwrap">
<code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#ListWrapper.unwrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.ListWrapper.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of myself as a list, and unwrap any wrapper objects in me.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.wrap.MutableMappingWrapper">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.wrap.</code><code class="sig-name descname">MutableMappingWrapper</code><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#MutableMappingWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.MutableMappingWrapper" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="LiSE.allegedb.wrap.MutableMappingWrapper.unwrap">
<code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#MutableMappingWrapper.unwrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.MutableMappingWrapper.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of myself as a dict, and unwrap any wrapper objects in me.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.wrap.MutableSequenceWrapper">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.wrap.</code><code class="sig-name descname">MutableSequenceWrapper</code><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#MutableSequenceWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.MutableSequenceWrapper" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="LiSE.allegedb.wrap.MutableSequenceWrapper.unwrap">
<code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#MutableSequenceWrapper.unwrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.MutableSequenceWrapper.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of myself as a list, and unwrap any wrapper objects in me.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.wrap.MutableWrapper">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.wrap.</code><code class="sig-name descname">MutableWrapper</code><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#MutableWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.MutableWrapper" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.wrap.MutableWrapperDictList">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.wrap.</code><code class="sig-name descname">MutableWrapperDictList</code><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#MutableWrapperDictList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.MutableWrapperDictList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.wrap.MutableWrapperSet">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.wrap.</code><code class="sig-name descname">MutableWrapperSet</code><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#MutableWrapperSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.MutableWrapperSet" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="LiSE.allegedb.wrap.MutableWrapperSet.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">element</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#MutableWrapperSet.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.MutableWrapperSet.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an element.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.wrap.MutableWrapperSet.discard">
<code class="sig-name descname">discard</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">element</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#MutableWrapperSet.discard"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.MutableWrapperSet.discard" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an element.  Do not raise an exception if absent.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.wrap.MutableWrapperSet.pop">
<code class="sig-name descname">pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#MutableWrapperSet.pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.MutableWrapperSet.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the popped value.  Raise KeyError if empty.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.wrap.MutableWrapperSet.remove">
<code class="sig-name descname">remove</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">element</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#MutableWrapperSet.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.MutableWrapperSet.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an element. If not a member, raise a KeyError.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.wrap.MutableWrapperSet.unwrap">
<code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#MutableWrapperSet.unwrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.MutableWrapperSet.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of myself as a set, and unwrap any wrapper objects in me.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.wrap.SetWrapper">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.wrap.</code><code class="sig-name descname">SetWrapper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">getter</span></em>, <em class="sig-param"><span class="n">setter</span></em>, <em class="sig-param"><span class="n">outer</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#SetWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.SetWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>A set synchronized with a serialized field.</p>
<p>This is meant to be used in allegedb entities (graph, node, or
edge), for when the user stores a set in them.</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.wrap.SubDictWrapper">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.wrap.</code><code class="sig-name descname">SubDictWrapper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">getter</span></em>, <em class="sig-param"><span class="n">setter</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#SubDictWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.SubDictWrapper" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.wrap.SubListWrapper">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.wrap.</code><code class="sig-name descname">SubListWrapper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">getter</span></em>, <em class="sig-param"><span class="n">setter</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#SubListWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.SubListWrapper" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="LiSE.allegedb.wrap.SubListWrapper.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">object</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#SubListWrapper.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.SubListWrapper.append" title="Permalink to this definition">¶</a></dt>
<dd><p>S.append(value) – append value to the end of the sequence</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.allegedb.wrap.SubListWrapper.insert">
<code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em>, <em class="sig-param"><span class="n">object</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#SubListWrapper.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.SubListWrapper.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>S.insert(index, value) – insert value before index</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.wrap.SubSetWrapper">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.wrap.</code><code class="sig-name descname">SubSetWrapper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">getter</span></em>, <em class="sig-param"><span class="n">setter</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#SubSetWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.SubSetWrapper" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.allegedb.wrap.UnwrappingDict">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.allegedb.wrap.</code><code class="sig-name descname">UnwrappingDict</code><a class="reference internal" href="../../../_modules/LiSE/allegedb/wrap.html#UnwrappingDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.allegedb.wrap.UnwrappingDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Dict that stores the data from the wrapper classes but won’t store those objects themselves.</p>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">LiSE</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../manual.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../manual.html#ide">IDE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">LiSE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ELiDE/index.html">ELiDE</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">allegedb</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#usage">usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.allegedb">ORM</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.allegedb.cache">cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.allegedb.graph">graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.allegedb.query">query</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.allegedb.wrap">wrap</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../../../ELiDE/index.html" title="previous chapter">ELiDE</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;Zachary Spector.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/LiSE/LiSE/allegedb/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>