
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LiSE &#8212; LiSE 0.9dev documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ELiDE" href="../ELiDE/index.html" />
    <link rel="prev" title="Introduction" href="../manual.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="lise">
<h1>LiSE<a class="headerlink" href="#lise" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<p>The only LiSE class that you should ever instantiate yourself is
Engine. All the other simulation objects should be
created and accessed through it. Engine is instantiated
with two arguments, which are file names of SQLite databases that will
be created if needed; the first will hold the state of the simulation,
including history, while the second will hold rules, including copies
of the functions used in the rules.</p>
<div class="section" id="world-modelling">
<h2>World Modelling<a class="headerlink" href="#world-modelling" title="Permalink to this headline">¶</a></h2>
<p>Start by calling the engine’s <code class="docutils literal notranslate"><span class="pre">new_character</span></code> method with a string
<code class="docutils literal notranslate"><span class="pre">name</span></code>.  This will return a character object with the name you
provided. Now draw a map by calling the method <code class="docutils literal notranslate"><span class="pre">new_place</span></code> with many
different string <code class="docutils literal notranslate"><span class="pre">name</span></code> s, then linking them together with the
method <code class="docutils literal notranslate"><span class="pre">new_portal(origin,</span> <span class="pre">destination)</span></code>.  To store data pertaining
to some particular place, retrieve the place from the <code class="docutils literal notranslate"><span class="pre">place</span></code>
mapping of the character: if the character is <code class="docutils literal notranslate"><span class="pre">world</span></code> and the place
name is <code class="docutils literal notranslate"><span class="pre">'home'</span></code>, you might do it like
<code class="docutils literal notranslate"><span class="pre">home</span> <span class="pre">=</span> <span class="pre">world.place['home']</span></code>. Portals are retrieved from the <code class="docutils literal notranslate"><span class="pre">portal</span></code>
mapping, where you’ll need the origin and the destination: if there’s
a portal from <code class="docutils literal notranslate"><span class="pre">'home'</span></code> to <code class="docutils literal notranslate"><span class="pre">'narnia'</span></code>, you can get it like
<code class="docutils literal notranslate"><span class="pre">wardrobe</span> <span class="pre">=</span> <span class="pre">world.portal['home']['narnia']</span></code>, but if you haven’t also
made another portal going the other way,
<code class="docutils literal notranslate"><span class="pre">world.portal['narnia']['home']</span></code> will raise <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.</p>
<p>Things, usually being located in places (but possibly in other things),
are most conveniently created by the <code class="docutils literal notranslate"><span class="pre">new_thing</span></code> method of Place objects:
<code class="docutils literal notranslate"><span class="pre">alice</span> <span class="pre">=</span> <span class="pre">home.new_thing('alice')</span></code> gets you a new Thing object
located in <code class="docutils literal notranslate"><span class="pre">home</span></code>. Things can be retrieved like <code class="docutils literal notranslate"><span class="pre">alice</span> <span class="pre">=</span> <span class="pre">world.thing['alice']</span></code>.
Ultimately, things and places are both just nodes, and both can be
retrieved in a character’s <code class="docutils literal notranslate"><span class="pre">node</span></code> mapping, but only things have
methods like <code class="docutils literal notranslate"><span class="pre">travel_to</span></code>, which finds a path to a destination
and schedules movement along it.</p>
<p>You can store data in things, places, and portals by treating them
like dictionaries.  If you want to store data in a character, use its
<code class="docutils literal notranslate"><span class="pre">stat</span></code> property as a dictionary instead. Data stored in these
objects, and in the <code class="docutils literal notranslate"><span class="pre">universal</span></code> property of the engine, can vary
over time. The engine’s <code class="docutils literal notranslate"><span class="pre">eternal</span></code> property is not time-sensitive,
and is mainly for storing settings, not simulation data.</p>
</div>
<div class="section" id="rule-creation">
<h2>Rule Creation<a class="headerlink" href="#rule-creation" title="Permalink to this headline">¶</a></h2>
<p>To create a rule, first decide what objects the rule should apply
to. You can put a rule on a character, thing, place, or portal; and
you can put a rule on a character’s <code class="docutils literal notranslate"><span class="pre">thing</span></code>, <code class="docutils literal notranslate"><span class="pre">place</span></code>, and
<code class="docutils literal notranslate"><span class="pre">portal</span></code> mappings, meaning the rule will be applied to <em>every</em> such
entity within the character, even if it didn’t exist when the rule was
declared.</p>
<p>All these items have a property <code class="docutils literal notranslate"><span class="pre">rule</span></code> that can be used as a
decorator. Use this to decorate a function that performs the rule’s
action by making some change to the world state.  Functions decorated
this way always get passed the engine as the first argument and the
character as the second; if the function is more specific than that, a
particular thing, place, or portal will be the third argument. This
will get you a rule object of the same name as your action function.</p>
<p>At first, the rule object will not have any triggers, meaning the action
will never happen. If you want it to run on <em>every</em> tick, call its
<code class="docutils literal notranslate"><span class="pre">always</span></code> method and think no more of it. But if you want to be
more selective, use the rule’s <code class="docutils literal notranslate"><span class="pre">trigger</span></code> decorator on another
function with the same signature, and have it return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the
world is in such a state that the rule ought to run. There is nothing
really stopping you from modifying the rule from inside a trigger, but
it’s not recommended.</p>
<p>If you like, you can also add prerequisites. These are like triggers,
but use the <code class="docutils literal notranslate"><span class="pre">prereq</span></code> decorator, and should return <code class="docutils literal notranslate"><span class="pre">True</span></code> <em>unless</em>
the action should <em>not</em> happen; if a single prerequisite returns
<code class="docutils literal notranslate"><span class="pre">False</span></code>, the action is cancelled.</p>
</div>
<div class="section" id="time-control">
<h2>Time Control<a class="headerlink" href="#time-control" title="Permalink to this headline">¶</a></h2>
<p>The current time is always accessible from the engine’s <code class="docutils literal notranslate"><span class="pre">branch</span></code> and
<code class="docutils literal notranslate"><span class="pre">turn</span></code> properties. In the common case where time is advancing
forward one tick at a time, it should be done with the engine’s
<code class="docutils literal notranslate"><span class="pre">next_turn</span></code> method, which polls all the game rules before going to
the next tick; but you can also change the time whenever you want, as
long as <code class="docutils literal notranslate"><span class="pre">branch</span></code> is a string and <code class="docutils literal notranslate"><span class="pre">turn</span></code> is an integer. The rules
will never be followed in response to your changing the time “by
hand”.</p>
<p>It is possible–indeed, expected–to change the time as part of the
action of a rule. This is how you would make something happen after a
delay. Say you want a rule that puts the character <code class="docutils literal notranslate"><span class="pre">alice</span></code> to sleep,
then wakes her up after eight turns (presumably hour-long).:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alice</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">character</span><span class="p">[</span><span class="s1">&#39;alice&#39;</span><span class="p">]</span>

<span class="nd">@alice</span><span class="o">.</span><span class="n">rule</span>
<span class="k">def</span> <span class="nf">sleep</span><span class="p">(</span><span class="n">character</span><span class="p">):</span>
    <span class="n">character</span><span class="o">.</span><span class="n">stat</span><span class="p">[</span><span class="s1">&#39;awake&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">start_turn</span> <span class="o">=</span> <span class="n">character</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">turn</span>
    <span class="k">with</span> <span class="n">character</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">plan</span><span class="p">():</span>
        <span class="n">character</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">turn</span> <span class="o">+=</span> <span class="mi">8</span>
        <span class="n">character</span><span class="o">.</span><span class="n">stat</span><span class="p">[</span><span class="s1">&#39;awake&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">character</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">turn</span> <span class="o">=</span> <span class="n">start_turn</span>
</pre></div>
</div>
<p>Remember to set the time back to when you started when you’re done
making all your plans.</p>
</div>
<div class="section" id="input-prompts">
<h2>Input Prompts<a class="headerlink" href="#input-prompts" title="Permalink to this headline">¶</a></h2>
<p>LiSE itself doesn’t know what a player is or how to accept input from them,
but does use some conventions for communicating with a user interface
such as ELiDE.</p>
<p>To ask the player to make a decision, first define a method for them to
call, then return a menu description like this one.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@engine</span><span class="o">.</span><span class="n">method</span>
<span class="k">def</span> <span class="nf">wake_alice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">character</span><span class="p">[</span><span class="s1">&#39;alice&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stat</span><span class="p">[</span><span class="s1">&#39;awake&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

<span class="n">alice</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">character</span><span class="p">[</span><span class="s1">&#39;alice&#39;</span><span class="p">]</span>

<span class="nd">@alice</span><span class="o">.</span><span class="n">rule</span>
<span class="k">def</span> <span class="nf">wakeup</span><span class="p">(</span><span class="n">character</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;Wake up?&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;Yes&quot;</span><span class="p">,</span> <span class="n">character</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">wake_alice</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;No&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
</pre></div>
</div>
<p>Only methods defined with the <code class="docutils literal notranslate"><span class="pre">&#64;engine.method</span></code> decorator may be used in a menu.</p>
</div>
<div class="section" id="module-LiSE.engine">
<span id="engine"></span><h2>engine<a class="headerlink" href="#module-LiSE.engine" title="Permalink to this headline">¶</a></h2>
<p>The “engine” of LiSE is an object relational mapper with special
stores for game data and entities, as well as properties for manipulating the
flow of time.</p>
<dl class="py class">
<dt id="LiSE.engine.AbstractEngine">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.engine.</code><code class="sig-name descname">AbstractEngine</code><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine" title="Permalink to this definition">¶</a></dt>
<dd><p>Parent class to the real Engine as well as EngineProxy.</p>
<p>Implements serialization and the __getattr__ for stored methods.</p>
<p>By default, the deserializers will refuse to create LiSE entities.
If you want them to, use my <code class="docutils literal notranslate"><span class="pre">loading</span></code> property to open a <code class="docutils literal notranslate"><span class="pre">with</span></code>
block, in which deserialized entities will be created as needed.</p>
<dl class="py method">
<dt id="LiSE.engine.AbstractEngine.coinflip">
<code class="sig-name descname">coinflip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine.coinflip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine.coinflip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True or False with equal probability.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.AbstractEngine.dice">
<code class="sig-name descname">dice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine.dice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine.dice" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll <code class="docutils literal notranslate"><span class="pre">n</span></code> dice with <code class="docutils literal notranslate"><span class="pre">d</span></code> faces, and yield the results.</p>
<p>This is an iterator. You’ll get the result of each die in
successon.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.AbstractEngine.dice_check">
<code class="sig-name descname">dice_check</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">target</span></em>, <em class="sig-param"><span class="n">comparator</span><span class="o">=</span><span class="default_value">'&lt;='</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine.dice_check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine.dice_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll <code class="docutils literal notranslate"><span class="pre">n</span></code> dice with <code class="docutils literal notranslate"><span class="pre">d</span></code> sides, sum them, and compare</p>
<p>If <code class="docutils literal notranslate"><span class="pre">comparator</span></code> is provided, use it instead of the default &lt;=.
You may use a string like ‘&lt;’ or ‘&gt;=’.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.AbstractEngine.percent_chance">
<code class="sig-name descname">percent_chance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pct</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine.percent_chance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine.percent_chance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True or False with a given percentile probability</p>
<p>Values not between 0 and 100 are treated as though they
were 0 or 100, whichever is nearer.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.AbstractEngine.roll_die">
<code class="sig-name descname">roll_die</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractEngine.roll_die"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractEngine.roll_die" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll a die with <code class="docutils literal notranslate"><span class="pre">d</span></code> faces. Return the result.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.AbstractSchema">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.engine.</code><code class="sig-name descname">AbstractSchema</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">engine</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#AbstractSchema"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.AbstractSchema" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.engine.DummyEntity">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.engine.</code><code class="sig-name descname">DummyEntity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">engine</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#DummyEntity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.DummyEntity" title="Permalink to this definition">¶</a></dt>
<dd><p>Something to use in place of a node or edge</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.Engine">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.engine.</code><code class="sig-name descname">Engine</code><span class="sig-paren">(</span><em class="sig-param">worlddb='world.db'</em>, <em class="sig-param">*</em>, <em class="sig-param">string='strings.json'</em>, <em class="sig-param">function='function.py'</em>, <em class="sig-param">method='method.py'</em>, <em class="sig-param">trigger='trigger.py'</em>, <em class="sig-param">prereq='prereq.py'</em>, <em class="sig-param">action='action.py'</em>, <em class="sig-param">connect_args={}</em>, <em class="sig-param">schema_cls=&lt;class 'LiSE.engine.NullSchema'&gt;</em>, <em class="sig-param">alchemy=False</em>, <em class="sig-param">commit_modulus=None</em>, <em class="sig-param">random_seed=None</em>, <em class="sig-param">logfun=None</em>, <em class="sig-param">validate=False</em>, <em class="sig-param">clear=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine" title="Permalink to this definition">¶</a></dt>
<dd><p>LiSE, the Life Simulator Engine.</p>
<p>Each instance of LiSE maintains a connection to a database
representing the state of a simulated world. Simulation rules
within this world are described by lists of Python functions, some
of which make changes to the world.</p>
<p>The top-level data structure within LiSE is the character. Most
data within the world model is kept in some character or other;
these will quite frequently represent people, but can be readily
adapted to represent any kind of data that can be comfortably
described as a graph or a JSON object. Every change to a character
will be written to the database.</p>
<p>LiSE tracks history as a series of turns. In each turn, each
simulation rule is evaluated once for each of the simulated
entities it’s been applied to. World changes in a given turn are
remembered together, such that the whole world state can be
rewound: simply set the properties <code class="docutils literal notranslate"><span class="pre">branch</span></code> and <code class="docutils literal notranslate"><span class="pre">turn</span></code> back to
what they were just before the change you want to undo.</p>
<p>Properties:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">branch</span></code>: The fork of the timestream that we’re on.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">turn</span></code>: Units of time that have passed since the sim started.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: <code class="docutils literal notranslate"><span class="pre">(branch,</span> <span class="pre">turn)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tick</span></code>: A counter of how many changes have occurred this turn</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">character</span></code>: A mapping of <a class="reference internal" href="#LiSE.engine.Engine.Character" title="LiSE.engine.Engine.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></a> objects by name.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rule</span></code>: A mapping of all rules that have been made.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rulebook</span></code>: A mapping of lists of rules. They are followed in
their order.  A whole rulebook full of rules may be assigned to
an entity at once.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">trigger</span></code>: A mapping of functions that might trigger a rule.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prereq</span></code>: A mapping of functions a rule might require to return
<code class="docutils literal notranslate"><span class="pre">True</span></code> for it to run.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">action</span></code>: A mapping of functions that might manipulate the world
state as a result of a rule running.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">function</span></code>: A mapping of generic functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span></code>: A mapping of strings, probably shown to the player
at some point.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eternal</span></code>: Mapping of arbitrary serializable objects. It isn’t
sensitive to sim-time. A good place to keep game settings.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">universal</span></code>: Another mapping of arbitrary serializable
objects, but this one <em>is</em> sensitive to sim-time. Each turn, the
state of the randomizer is saved here under the key
<code class="docutils literal notranslate"><span class="pre">'rando_state'</span></code>.</p></li>
</ul>
<dl class="py class">
<dt id="LiSE.engine.Engine.Character">
<em class="property">class </em><code class="sig-name descname">Character</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">db</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character" title="Permalink to this definition">¶</a></dt>
<dd><p>A digraph that follows game rules and has a containment hierarchy</p>
<p>Nodes in a Character are subcategorized into Things and
Places. Things have locations, and those locations may be Places
or other Things. To get at those, use the <cite>thing</cite> and <cite>place</cite>
mappings – but in situations where the distinction does not matter,
you may simply address the Character as a mapping, as in NetworkX.</p>
<p>Characters may have avatars in other Characters. These are just
nodes. You can apply rules to a Character’s avatars, and thus to
any collection of nodes you want, perhaps in many different
Characters. The <cite>avatar</cite> attribute handles this. It is a mapping,
keyed by the other Character’s name, then by the name of the node
that is this Character’s avatar. In the common case where a
Character has exactly one avatar, it may be retrieved as
<cite>avatar.only</cite>. When it has more than one avatar, but only has
any avatars in a single other Character, you can get the mapping
of avatars in that Character as <cite>avatar.node</cite>. Add avatars with the
<cite>add_avatar</cite> method and remove them with <cite>del_avatar</cite>.</p>
<p>You can assign rules to Characters with their <cite>rule</cite> attribute,
typically using it as a decorator (see the documentation for
the <cite>rule</cite> module). You can do the same to some of Character’s
attributes:</p>
<ul class="simple">
<li><p><cite>thing.rule</cite> to make a rule run on all Things in this Character
every turn</p></li>
<li><p><cite>place.rule</cite> to make a rule run on all Places in this Character
every turn</p></li>
<li><p><cite>node.rule</cite> to make a rule run on all Things and Places in this
Character every turn</p></li>
<li><p><cite>avatar.rule</cite> to make a rule run on all the avatars this
Character has every turn, regardless of what Character the
avatar is in</p></li>
<li><p><cite>adj.rule</cite> to make a rule run on all the edges this Character
has every turn</p></li>
</ul>
<dl class="py class">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping">
<em class="property">class </em><code class="sig-name descname">AvatarGraphMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">char</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping of other characters in which one has an avatar.</p>
<p>Maps to a mapping of the avatars themselves, unless there’s
only one other character you have avatars in, in which case
this maps to those.</p>
<p>If you have only one avatar anywhere, you can pretend this
is that entity.</p>
<dl class="py class">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping.CharacterAvatarMapping">
<em class="property">class </em><code class="sig-name descname">CharacterAvatarMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">outer</span></em>, <em class="sig-param"><span class="n">graphn</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping.CharacterAvatarMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of avatars of one Character in another Character.</p>
<dl class="py method">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping.CharacterAvatarMapping.only">
<em class="property">property </em><code class="sig-name descname">only</code><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping.CharacterAvatarMapping.only" title="Permalink to this definition">¶</a></dt>
<dd><p>If I have only one avatar, return it; else error</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping.node">
<em class="property">property </em><code class="sig-name descname">node</code><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping.node" title="Permalink to this definition">¶</a></dt>
<dd><p>If I have avatars in only one graph, return a map of them</p>
<p>Otherwise, raise AttributeError.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.AvatarGraphMapping.only">
<em class="property">property </em><code class="sig-name descname">only</code><a class="headerlink" href="#LiSE.engine.Engine.Character.AvatarGraphMapping.only" title="Permalink to this definition">¶</a></dt>
<dd><p>If I have only one avatar, return it</p>
<p>Otherwise, raise AttributeError.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.Engine.Character.PlaceMapping">
<em class="property">class </em><code class="sig-name descname">PlaceMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PlaceMapping" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> objects that are in a <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></p>
<dl class="py method">
<dt id="LiSE.engine.Engine.Character.PlaceMapping.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">E</em>, <span class="optional">]</span><em class="sig-param">**F</em><span class="sig-paren">)</span> &#x2192; None.  Update D from mapping/iterable E and F.<a class="headerlink" href="#LiSE.engine.Engine.Character.PlaceMapping.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.Engine.Character.PortalPredecessorsMapping">
<em class="property">class </em><code class="sig-name descname">PortalPredecessorsMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalPredecessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of nodes that have at least one incoming edge.</p>
<p>Maps to another mapping keyed by the origin nodes, which maps to
Portal objects.</p>
<dl class="py class">
<dt id="LiSE.engine.Engine.Character.PortalPredecessorsMapping.Predecessors">
<em class="property">class </em><code class="sig-name descname">Predecessors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">dest</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalPredecessorsMapping.Predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of possible origins from some destination.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping">
<em class="property">class </em><code class="sig-name descname">PortalSuccessorsMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of nodes that have at least one outgoing edge.</p>
<p>Maps them to another mapping, keyed by the destination nodes,
which maps to Portal objects.</p>
<dl class="py class">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors">
<em class="property">class </em><code class="sig-name descname">Successors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">orig</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping for possible destinations from some node.</p>
<dl class="py method">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors.send">
<em class="property">static </em><code class="sig-name descname">send</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Call all listeners to <code class="docutils literal notranslate"><span class="pre">dest</span></code> and to my <code class="docutils literal notranslate"><span class="pre">orig</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">E</em>, <span class="optional">]</span><em class="sig-param">**F</em><span class="sig-paren">)</span> &#x2192; None.  Update D from mapping/iterable E and F.<a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping.Successors.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping.character">
<em class="property">property </em><code class="sig-name descname">character</code><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.PortalSuccessorsMapping.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.PortalSuccessorsMapping.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively update the stats of all portals</p>
<p>Input should be a dictionary of dictionaries of dictionaries
–just like networkx <code class="docutils literal notranslate"><span class="pre">DiGraph._edge</span></code>.</p>
<p>This will create portals as needed, but will only delete
them if you set their value to <code class="docutils literal notranslate"><span class="pre">None</span></code>. Likewise, stats
not specified in the input will be left untouched, if they
are already present, but you can set them to <code class="docutils literal notranslate"><span class="pre">None</span></code> to
delete them.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.Engine.Character.ThingMapping">
<em class="property">class </em><code class="sig-name descname">ThingMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingMapping" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Thing</span></code> objects that are in a <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></p>
<dl class="py method">
<dt id="LiSE.engine.Engine.Character.ThingMapping.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.ThingMapping.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.Engine.Character.ThingPlaceMapping">
<em class="property">class </em><code class="sig-name descname">ThingPlaceMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingPlaceMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>GraphNodeMapping but for Place and Thing</p>
<dl class="py method">
<dt id="LiSE.engine.Engine.Character.ThingPlaceMapping.character">
<em class="property">property </em><code class="sig-name descname">character</code><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingPlaceMapping.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.ThingPlaceMapping.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingPlaceMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.ThingPlaceMapping.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#LiSE.engine.Engine.Character.ThingPlaceMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.add_avatar">
<code class="sig-name descname">add_avatar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.add_avatar" title="Permalink to this definition">¶</a></dt>
<dd><p>Start keeping track of an avatar</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.add_place">
<code class="sig-name descname">add_place</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node_for_adding</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.add_place" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.add_places_from">
<code class="sig-name descname">add_places_from</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attrs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.add_places_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a series of place names and add the lot.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.add_portal">
<code class="sig-name descname">add_portal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">origin</span></em>, <em class="sig-param"><span class="n">destination</span></em>, <em class="sig-param"><span class="n">symmetrical</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.add_portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect the origin to the destination with a <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>.</p>
<p>Keyword arguments are the <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>’s
attributes. Exception: if keyword <code class="docutils literal notranslate"><span class="pre">symmetrical</span></code> == <code class="docutils literal notranslate"><span class="pre">True</span></code>,
a mirror-<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> will be placed in the opposite
direction between the same nodes. It will always appear to
have the placed <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>’s stats, and any change to the
mirror <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>’s stats will affect the placed
<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.add_portals_from">
<code class="sig-name descname">add_portals_from</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="n">symmetrical</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.add_portals_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Make portals for a sequence of (origin, destination) pairs</p>
<p>Actually, triples are acceptable too, in which case the third
item is a dictionary of stats for the new <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>.</p>
<p>If optional argument <code class="docutils literal notranslate"><span class="pre">symmetrical</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, all
the <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> instances will have a mirror portal going
in the opposite direction, which will always have the same
stats.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.add_thing">
<code class="sig-name descname">add_thing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">location</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.add_thing" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a new Thing and set its location</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.add_things_from">
<code class="sig-name descname">add_things_from</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attrs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.add_things_from" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="LiSE.engine.Engine.Character.adj_cls">
<code class="sig-name descname">adj_cls</code><a class="headerlink" href="#LiSE.engine.Engine.Character.adj_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Character.PortalSuccessorsMapping</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.avatars">
<code class="sig-name descname">avatars</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.avatars" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all my avatars</p>
<p>Regardless of what character they are in.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.character">
<em class="property">property </em><code class="sig-name descname">character</code><a class="headerlink" href="#LiSE.engine.Engine.Character.character" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.facade">
<code class="sig-name descname">facade</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.facade" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.historical">
<code class="sig-name descname">historical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stat</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.historical" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a historical view on the given stat</p>
<p>This functions like the value of the stat, but changes
when you time travel. Comparisons performed on the
historical view can be passed to <code class="docutils literal notranslate"><span class="pre">engine.turns_when</span></code>
to find out when the comparison held true.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.new_portal">
<code class="sig-name descname">new_portal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">origin</span></em>, <em class="sig-param"><span class="n">destination</span></em>, <em class="sig-param"><span class="n">symmetrical</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.new_portal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="LiSE.engine.Engine.Character.node_map_cls">
<code class="sig-name descname">node_map_cls</code><a class="headerlink" href="#LiSE.engine.Engine.Character.node_map_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Character.ThingPlaceMapping</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.place2thing">
<code class="sig-name descname">place2thing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">location</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.place2thing" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a Place into a Thing with the given location.</p>
<p>It will keep all its attached Portals.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.portals">
<code class="sig-name descname">portals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.portals" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all portals.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.engine.Engine.Character.pred_cls">
<code class="sig-name descname">pred_cls</code><a class="headerlink" href="#LiSE.engine.Engine.Character.pred_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Character.PortalPredecessorsMapping</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.remove_avatar">
<code class="sig-name descname">remove_avatar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.remove_avatar" title="Permalink to this definition">¶</a></dt>
<dd><p>This is no longer my avatar, though it still exists</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.remove_place">
<code class="sig-name descname">remove_place</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">place</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.remove_place" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.remove_portal">
<em class="property">property </em><code class="sig-name descname">remove_portal</code><a class="headerlink" href="#LiSE.engine.Engine.Character.remove_portal" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.remove_thing">
<code class="sig-name descname">remove_thing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">thing</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.remove_thing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Character.thing2place">
<code class="sig-name descname">thing2place</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Character.thing2place" title="Permalink to this definition">¶</a></dt>
<dd><p>Unset a Thing’s location, and thus turn it into a Place.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.Engine.Place">
<em class="property">class </em><code class="sig-name descname">Place</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Place" title="Permalink to this definition">¶</a></dt>
<dd><p>The kind of node where a thing might ultimately be located.</p>
<dl class="py method">
<dt id="LiSE.engine.Engine.Place.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Place.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove myself from the world model immediately.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.Engine.Portal">
<em class="property">class </em><code class="sig-name descname">Portal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">idx</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection between two Places that Things may travel along.</p>
<p>Portals are one-way, but you can make one appear two-way by
setting the <code class="docutils literal notranslate"><span class="pre">symmetrical</span></code> key to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
eg. <code class="docutils literal notranslate"><span class="pre">character.add_portal(orig,</span> <span class="pre">dest,</span> <span class="pre">symmetrical=True)</span></code>.
The portal going the other way will appear to have all the
stats of this one, and attempting to set a stat on it will
set it here instead.</p>
<dl class="py method">
<dt id="LiSE.engine.Engine.Portal.character">
<em class="property">property </em><code class="sig-name descname">character</code><a class="headerlink" href="#LiSE.engine.Engine.Portal.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Portal.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Portal.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove myself from my <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>.</p>
<p>For symmetry with <code class="xref py py-class docutils literal notranslate"><span class="pre">Thing</span></code> and :class`Place`.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Portal.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.engine.Engine.Portal.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Portal.historical">
<code class="sig-name descname">historical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stat</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Portal.historical" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a reference to the values that a stat has had in the past.</p>
<p>You can use the reference in comparisons to make a history
query, and execute the query by calling it, or passing it to
<code class="docutils literal notranslate"><span class="pre">self.engine.ticks_when</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Portal.reciprocal">
<em class="property">property </em><code class="sig-name descname">reciprocal</code><a class="headerlink" href="#LiSE.engine.Engine.Portal.reciprocal" title="Permalink to this definition">¶</a></dt>
<dd><p>If there’s another Portal connecting the same origin and
destination that I do, but going the opposite way, return
it. Else raise KeyError.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Portal.unwrap">
<code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Portal.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of myself as a dict, and unwrap any wrapper objects in me.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Portal.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Portal.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Works like regular update, but only actually updates when the new
value and the old value differ. This is necessary to prevent
certain infinite loops.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>d</strong> – a dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.Engine.QueryEngine">
<em class="property">class </em><code class="sig-name descname">QueryEngine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dbstring</span></em>, <em class="sig-param"><span class="n">connect_args</span></em>, <em class="sig-param"><span class="n">alchemy</span></em>, <em class="sig-param"><span class="n">pack</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">unpack</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.avatar_rulebook_dump">
<code class="sig-name descname">avatar_rulebook_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.avatar_rulebook_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.avatar_rules_changes_dump">
<code class="sig-name descname">avatar_rules_changes_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.avatar_rules_changes_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.avatar_rules_handled_dump">
<code class="sig-name descname">avatar_rules_handled_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.avatar_rules_handled_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.avatar_set">
<code class="sig-name descname">avatar_set</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">isav</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.avatar_set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.avatars_dump">
<code class="sig-name descname">avatars_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.avatars_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.branch_descendants">
<code class="sig-name descname">branch_descendants</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">branch</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.branch_descendants" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.character_place_rulebook_dump">
<code class="sig-name descname">character_place_rulebook_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.character_place_rulebook_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.character_place_rules_changes_dump">
<code class="sig-name descname">character_place_rules_changes_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.character_place_rules_changes_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.character_place_rules_handled_dump">
<code class="sig-name descname">character_place_rules_handled_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.character_place_rules_handled_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.character_portal_rulebook_dump">
<code class="sig-name descname">character_portal_rulebook_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.character_portal_rulebook_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.character_portal_rules_changes_dump">
<code class="sig-name descname">character_portal_rules_changes_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.character_portal_rules_changes_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.character_portal_rules_handled_dump">
<code class="sig-name descname">character_portal_rules_handled_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.character_portal_rules_handled_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.character_rulebook_dump">
<code class="sig-name descname">character_rulebook_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.character_rulebook_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.character_rules_changes_dump">
<code class="sig-name descname">character_rules_changes_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.character_rules_changes_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.character_rules_handled_dump">
<code class="sig-name descname">character_rules_handled_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.character_rules_handled_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.character_thing_rulebook_dump">
<code class="sig-name descname">character_thing_rulebook_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.character_thing_rulebook_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.character_thing_rules_changes_dump">
<code class="sig-name descname">character_thing_rules_changes_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.character_thing_rules_changes_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.character_thing_rules_handled_dump">
<code class="sig-name descname">character_thing_rules_handled_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.character_thing_rules_handled_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.characters">
<code class="sig-name descname">characters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.characters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.characters_dump">
<code class="sig-name descname">characters_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.characters_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.comparison">
<code class="sig-name descname">comparison</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entity0</span></em>, <em class="sig-param"><span class="n">stat0</span></em>, <em class="sig-param"><span class="n">entity1</span></em>, <em class="sig-param"><span class="n">stat1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">oper</span><span class="o">=</span><span class="default_value">'eq'</span></em>, <em class="sig-param"><span class="n">windows</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.comparison" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.complete_turn">
<code class="sig-name descname">complete_turn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.complete_turn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.count_all_table">
<code class="sig-name descname">count_all_table</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tbl</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.count_all_table" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.exist_edge">
<code class="sig-name descname">exist_edge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">extant</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.exist_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare whether or not this edge exists.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.exist_node">
<code class="sig-name descname">exist_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">extant</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.exist_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare that the node exists or doesn’t.</p>
<p>Inserts a new record or updates an old one, as needed.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.get_rulebook_char">
<code class="sig-name descname">get_rulebook_char</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rulemap</span></em>, <em class="sig-param"><span class="n">character</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.get_rulebook_char" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.handled_avatar_rule">
<code class="sig-name descname">handled_avatar_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">rulebook</span></em>, <em class="sig-param"><span class="n">rule</span></em>, <em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">av</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.handled_avatar_rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.handled_character_place_rule">
<code class="sig-name descname">handled_character_place_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">rulebook</span></em>, <em class="sig-param"><span class="n">rule</span></em>, <em class="sig-param"><span class="n">place</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.handled_character_place_rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.handled_character_portal_rule">
<code class="sig-name descname">handled_character_portal_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">rulebook</span></em>, <em class="sig-param"><span class="n">rule</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.handled_character_portal_rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.handled_character_rule">
<code class="sig-name descname">handled_character_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">rulebook</span></em>, <em class="sig-param"><span class="n">rule</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.handled_character_rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.handled_character_thing_rule">
<code class="sig-name descname">handled_character_thing_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">rulebook</span></em>, <em class="sig-param"><span class="n">rule</span></em>, <em class="sig-param"><span class="n">thing</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.handled_character_thing_rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.handled_node_rule">
<code class="sig-name descname">handled_node_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">rulebook</span></em>, <em class="sig-param"><span class="n">rule</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.handled_node_rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.handled_portal_rule">
<code class="sig-name descname">handled_portal_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">rulebook</span></em>, <em class="sig-param"><span class="n">rule</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.handled_portal_rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.init_table">
<code class="sig-name descname">init_table</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tbl</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.init_table" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.initdb">
<code class="sig-name descname">initdb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.initdb" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the database schema, both for allegedb and the special
extensions for LiSE</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.node_rulebook_dump">
<code class="sig-name descname">node_rulebook_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.node_rulebook_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.node_rules_changes_dump">
<code class="sig-name descname">node_rules_changes_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.node_rules_changes_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.node_rules_handled_dump">
<code class="sig-name descname">node_rules_handled_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.node_rules_handled_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.portal_rulebook_dump">
<code class="sig-name descname">portal_rulebook_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.portal_rulebook_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.portal_rules_changes_dump">
<code class="sig-name descname">portal_rules_changes_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.portal_rules_changes_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.portal_rules_handled_dump">
<code class="sig-name descname">portal_rules_handled_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.portal_rules_handled_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.rule_actions_dump">
<code class="sig-name descname">rule_actions_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.rule_actions_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.rule_prereqs_dump">
<code class="sig-name descname">rule_prereqs_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.rule_prereqs_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.rule_triggers_dump">
<code class="sig-name descname">rule_triggers_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.rule_triggers_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.rulebook_del_time">
<code class="sig-name descname">rulebook_del_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.rulebook_del_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.rulebook_get">
<code class="sig-name descname">rulebook_get</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rulebook</span></em>, <em class="sig-param"><span class="n">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.rulebook_get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.rulebook_set">
<code class="sig-name descname">rulebook_set</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rulebook</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">rules</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.rulebook_set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.rulebooks">
<code class="sig-name descname">rulebooks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.rulebooks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.rulebooks_dump">
<code class="sig-name descname">rulebooks_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.rulebooks_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.rulebooks_rules">
<code class="sig-name descname">rulebooks_rules</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.rulebooks_rules" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.rules_dump">
<code class="sig-name descname">rules_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.rules_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.senses_dump">
<code class="sig-name descname">senses_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.senses_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_avatar_rulebook">
<code class="sig-name descname">set_avatar_rulebook</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">char</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">rb</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_avatar_rulebook" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_character_place_rulebook">
<code class="sig-name descname">set_character_place_rulebook</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">char</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">rb</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_character_place_rulebook" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_character_portal_rulebook">
<code class="sig-name descname">set_character_portal_rulebook</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">char</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">rb</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_character_portal_rulebook" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_character_rulebook">
<code class="sig-name descname">set_character_rulebook</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">char</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">rb</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_character_rulebook" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_character_thing_rulebook">
<code class="sig-name descname">set_character_thing_rulebook</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">char</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">rb</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_character_thing_rulebook" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_node_rulebook">
<code class="sig-name descname">set_node_rulebook</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">rulebook</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_node_rulebook" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_portal_rulebook">
<code class="sig-name descname">set_portal_rulebook</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">rulebook</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_portal_rulebook" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_rule">
<code class="sig-name descname">set_rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">triggers</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">prereqs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">actions</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_rule_actions">
<code class="sig-name descname">set_rule_actions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">flist</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_rule_actions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_rule_prereqs">
<code class="sig-name descname">set_rule_prereqs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">flist</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_rule_prereqs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_rule_triggers">
<code class="sig-name descname">set_rule_triggers</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">flist</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_rule_triggers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_rulebook">
<code class="sig-name descname">set_rulebook</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">rules</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_rulebook" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.set_thing_loc">
<code class="sig-name descname">set_thing_loc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">thing</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">loc</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.set_thing_loc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.things_dump">
<code class="sig-name descname">things_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.things_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.turns_completed_dump">
<code class="sig-name descname">turns_completed_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.turns_completed_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.universal_del">
<code class="sig-name descname">universal_del</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.universal_del" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.universal_set">
<code class="sig-name descname">universal_set</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.universal_set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.QueryEngine.universals_dump">
<code class="sig-name descname">universals_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.QueryEngine.universals_dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.Engine.Thing">
<em class="property">class </em><code class="sig-name descname">Thing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Thing" title="Permalink to this definition">¶</a></dt>
<dd><p>The sort of item that has a particular location at any given time.</p>
<p>If a Thing is in a Place, it is standing still. If it is in a
Portal, it is moving through that Portal however fast it must in
order to arrive at the other end when it is scheduled to. If it is
in another Thing, then it is wherever that is, and moving the
same.</p>
<dl class="py method">
<dt id="LiSE.engine.Engine.Thing.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Thing.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Unset everything.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Thing.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Thing.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Get rid of this, starting now.</p>
<p>Apart from deleting the node, this also informs all its users
that it doesn’t exist and therefore can’t be their avatar
anymore.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Thing.follow_path">
<code class="sig-name descname">follow_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Thing.follow_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to several <code class="xref py py-class docutils literal notranslate"><span class="pre">Place`s</span> <span class="pre">in</span> <span class="pre">succession,</span> <span class="pre">deciding</span> <span class="pre">how</span> <span class="pre">long</span> <span class="pre">to</span>
<span class="pre">spend</span> <span class="pre">in</span> <span class="pre">each</span> <span class="pre">by</span> <span class="pre">consulting</span> <span class="pre">the</span> <span class="pre">``weight`</span></code> stat of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> connecting the one <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> to the next.</p>
<p>Return the total number of turns the travel will take. Raise
<code class="xref py py-class docutils literal notranslate"><span class="pre">TravelException</span></code> if I can’t follow the whole path,
either because some of its nodes don’t exist, or because I’m
scheduled to be somewhere else.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Thing.go_to_place">
<code class="sig-name descname">go_to_place</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">place</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Thing.go_to_place" title="Permalink to this definition">¶</a></dt>
<dd><p>Assuming I’m in a <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> that has a <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> direct
to the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code>, schedule myself to travel to the
given <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code>, taking an amount of time indicated by
the <code class="docutils literal notranslate"><span class="pre">weight</span></code> stat on the <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>, if given; else 1
turn.</p>
<p>Return the number of turns the travel will take.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Thing.location">
<em class="property">property </em><code class="sig-name descname">location</code><a class="headerlink" href="#LiSE.engine.Engine.Thing.location" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">Thing</span></code> or <code class="docutils literal notranslate"><span class="pre">Place</span></code> I’m in.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Thing.next_location">
<em class="property">property </em><code class="sig-name descname">next_location</code><a class="headerlink" href="#LiSE.engine.Engine.Thing.next_location" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.Thing.travel_to">
<code class="sig-name descname">travel_to</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">graph</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#LiSE.engine.Engine.Thing.travel_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the shortest path to the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> from where I am
now, and follow it.</p>
<p>If supplied, the <code class="docutils literal notranslate"><span class="pre">weight</span></code> stat of the :class:<a href="#id1"><span class="problematic" id="id2">`</span></a>Portal`s along
the path will be used in pathfinding, and for deciding how
long to stay in each Place along the way.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">graph</span></code> argument may be any NetworkX-style graph. It
will be used for pathfinding if supplied, otherwise I’ll use
my <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>. In either case, however, I will attempt
to actually follow the path using my <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>, which
might not be possible if the supplied <code class="docutils literal notranslate"><span class="pre">graph</span></code> and my
<code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code> are too different. If it’s not possible,
I’ll raise a <code class="xref py py-class docutils literal notranslate"><span class="pre">TravelException</span></code>, whose <code class="docutils literal notranslate"><span class="pre">subpath</span></code>
attribute holds the part of the path that I <em>can</em> follow. To
make me follow it, pass it to my <code class="docutils literal notranslate"><span class="pre">follow_path</span></code> method.</p>
<p>Return value is the number of turns the travel will take.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.add_character">
<code class="sig-name descname">add_character</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.add_character"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.add_character" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new character.</p>
<p>You’ll be able to access it as a <a class="reference internal" href="#LiSE.engine.Engine.Character" title="LiSE.engine.Engine.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></a> object by
looking up <code class="docutils literal notranslate"><span class="pre">name</span></code> in my <code class="docutils literal notranslate"><span class="pre">character</span></code> property.</p>
<p><code class="docutils literal notranslate"><span class="pre">data</span></code>, if provided, should be a networkx-compatible graph
object. Your new character will be a copy of it.</p>
<p>Any keyword arguments will be set as stats of the new character.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.advance">
<code class="sig-name descname">advance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Follow the next rule if available.</p>
<p>If we’ve run out of rules, reset the rules iterator.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.alias">
<code class="sig-name descname">alias</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">stat</span><span class="o">=</span><span class="default_value">'dummy'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.alias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pointer to a value for use in historical queries.</p>
<p>It will behave much as if you assigned the value to some entity
and then used its <code class="docutils literal notranslate"><span class="pre">historical</span></code> method to get a reference to
the set of its past values, which happens to contain only the
value you’ve provided here, <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> – the value to represent</p></li>
<li><p><strong>stat</strong> – what name to pretend its stat has; usually irrelevant</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.apply_choices">
<code class="sig-name descname">apply_choices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">choices</span></em>, <em class="sig-param"><span class="n">dry_run</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">perfectionist</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.apply_choices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.apply_choices" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate changes a player wants to make, and apply if acceptable.</p>
<p>Returns a pair of lists containing acceptance and rejection messages,
which the UI may present as it sees fit. They are always in a pair with
the change request as the zeroth item. The message may be None or a string.</p>
<p>Validator functions may return only a boolean indicating acceptance.
If they instead return a pair, the initial boolean indicates acceptance
and the following item is the message.</p>
<p>This function will not actually result in any simulation happening.
It creates a plan. See my <code class="docutils literal notranslate"><span class="pre">plan</span></code> context manager for the precise
meaning of this.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">dry_run=True</span></code> just return the acceptances and rejections without
really planning anything. With <code class="docutils literal notranslate"><span class="pre">perfectionist=True</span></code> apply changes if
and only if all of them are accepted.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.engine.Engine.char_cls">
<code class="sig-name descname">char_cls</code><a class="headerlink" href="#LiSE.engine.Engine.char_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.Character" title="LiSE.character.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.character.Character</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit changes and close the database.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.commit">
<code class="sig-name descname">commit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.commit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the state of all graphs to the database and commit the transaction.</p>
<p>Also saves the current branch, turn, and tick.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.critical">
<code class="sig-name descname">critical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.critical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.critical" title="Permalink to this definition">¶</a></dt>
<dd><p>Log a message at level ‘critical’</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.debug">
<code class="sig-name descname">debug</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.debug"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Log a message at level ‘debug’</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.del_character">
<code class="sig-name descname">del_character</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.del_character"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.del_character" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the Character from the database entirely.</p>
<p>This also deletes all its history. You’d better be sure.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.engine.Engine.edge_cls">
<code class="sig-name descname">edge_cls</code><a class="headerlink" href="#LiSE.engine.Engine.edge_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.portal.Portal" title="LiSE.portal.Portal"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.portal.Portal</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.error">
<code class="sig-name descname">error</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Log a message at level ‘error’</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.get_delta">
<code class="sig-name descname">get_delta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn_from</span></em>, <em class="sig-param"><span class="n">tick_from</span></em>, <em class="sig-param"><span class="n">turn_to</span></em>, <em class="sig-param"><span class="n">tick_to</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.get_delta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.get_delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary describing changes to the world.</p>
<p>Most keys will be character names, and their values will be
dictionaries of the character’s stats’ new values, with <code class="docutils literal notranslate"><span class="pre">None</span></code>
for deleted keys. Characters’ dictionaries have special keys
‘nodes’ and ‘edges’ which contain booleans indicating whether
the node or edge exists at the moment, and ‘node_val’ and
‘edge_val’ for the stats of those entities. For edges (also
called portals) these dictionaries are two layers deep, keyed
first by the origin, then by the destination.</p>
<p>Characters also have special keys for the various rulebooks
they have:</p>
<ul class="simple">
<li><p>‘character_rulebook’</p></li>
<li><p>‘avatar_rulebook’</p></li>
<li><p>‘character_thing_rulebook’</p></li>
<li><p>‘character_place_rulebook’</p></li>
<li><p>‘character_portal_rulebook’</p></li>
</ul>
<p>And each node and edge may have a ‘rulebook’ stat of its own.
If a node is a thing, it gets a ‘location’; when the ‘location’
is deleted, that means it’s back to being a place.</p>
<p>Keys at the top level that are not character names:</p>
<ul class="simple">
<li><p>‘rulebooks’, a dictionary keyed by the name of each changed</p></li>
</ul>
<p>rulebook, the value being a list of rule names
* ‘rules’, a dictionary keyed by the name of each changed rule,
containing any of the lists ‘triggers’, ‘prereqs’, and ‘actions’</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.get_turn_delta">
<code class="sig-name descname">get_turn_delta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">branch</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">turn</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tick</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">start_tick</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.get_turn_delta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.get_turn_delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of changes to the world within a given turn</p>
<p>Defaults to the present turn, and stops at the present tick
unless specified.</p>
<p>See the documentation for <code class="docutils literal notranslate"><span class="pre">get_delta</span></code> for a detailed
description of the delta format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>branch</strong> – branch of history, defaulting to the present branch</p></li>
<li><p><strong>turn</strong> – turn within the branch, defaulting to the present</p></li>
</ul>
</dd>
</dl>
<p>turn
:arg tick: tick at which to stop the delta, defaulting to the
present tick
:arg start_tick: tick at which to start the delta, default 0</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.info">
<code class="sig-name descname">info</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Log a message at level ‘info’</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.new_character">
<code class="sig-name descname">new_character</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.new_character"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.new_character" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new <a class="reference internal" href="#LiSE.engine.Engine.Character" title="LiSE.engine.Engine.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.engine.Engine.node_cls">
<code class="sig-name descname">node_cls</code><a class="headerlink" href="#LiSE.engine.Engine.node_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.place.Place" title="LiSE.place.Place"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.place.Place</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.engine.Engine.place_cls">
<code class="sig-name descname">place_cls</code><a class="headerlink" href="#LiSE.engine.Engine.place_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.place.Place" title="LiSE.place.Place"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.place.Place</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.engine.Engine.portal_cls">
<code class="sig-name descname">portal_cls</code><a class="headerlink" href="#LiSE.engine.Engine.portal_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.portal.Portal" title="LiSE.portal.Portal"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.portal.Portal</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.engine.Engine.query_engine_cls">
<code class="sig-name descname">query_engine_cls</code><a class="headerlink" href="#LiSE.engine.Engine.query_engine_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.query.QueryEngine" title="LiSE.query.QueryEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.query.QueryEngine</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.engine.Engine.thing_cls">
<code class="sig-name descname">thing_cls</code><a class="headerlink" href="#LiSE.engine.Engine.thing_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.thing.Thing" title="LiSE.thing.Thing"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.thing.Thing</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.turns_when">
<code class="sig-name descname">turns_when</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">qry</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.turns_when"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.turns_when" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield the turns in this branch when the query held true</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>qry</strong> – a Query, likely constructed by comparing the result</p>
</dd>
</dl>
<p>of a call to an entity’s <code class="docutils literal notranslate"><span class="pre">historical</span></code> method with the output
of <code class="docutils literal notranslate"><span class="pre">self.alias(..)</span></code> or another <code class="docutils literal notranslate"><span class="pre">historical(..)</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.engine.Engine.warning">
<code class="sig-name descname">warning</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#Engine.warning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.Engine.warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Log a message at level ‘warning’</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.FinalRule">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.engine.</code><code class="sig-name descname">FinalRule</code><a class="reference internal" href="../_modules/LiSE/engine.html#FinalRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.FinalRule" title="Permalink to this definition">¶</a></dt>
<dd><p>A singleton sentinel for the rule iterator</p>
</dd></dl>

<dl class="py exception">
<dt id="LiSE.engine.InnerStopIteration">
<em class="property">exception </em><code class="sig-prename descclassname">LiSE.engine.</code><code class="sig-name descname">InnerStopIteration</code><a class="reference internal" href="../_modules/LiSE/engine.html#InnerStopIteration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.InnerStopIteration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.engine.NextTurn">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.engine.</code><code class="sig-name descname">NextTurn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">engine</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#NextTurn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.NextTurn" title="Permalink to this definition">¶</a></dt>
<dd><p>Make time move forward in the simulation.</p>
<p>Calls <code class="docutils literal notranslate"><span class="pre">advance</span></code> repeatedly, returning a list of the rules’ return values.</p>
<p>I am also a <code class="docutils literal notranslate"><span class="pre">Signal</span></code>, so you can register functions to be
called when the simulation runs. Pass them to my <code class="docutils literal notranslate"><span class="pre">connect</span></code>
method.</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.engine.NullSchema">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.engine.</code><code class="sig-name descname">NullSchema</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">engine</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#NullSchema"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.NullSchema" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.engine.getnoplan">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.engine.</code><code class="sig-name descname">getnoplan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">attr</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">attrs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/engine.html#getnoplan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.engine.getnoplan" title="Permalink to this definition">¶</a></dt>
<dd><p>Attribute getter that raises an exception if in planning mode</p>
</dd></dl>

</div>
<div class="section" id="module-LiSE.character">
<span id="character"></span><h2>character<a class="headerlink" href="#module-LiSE.character" title="Permalink to this headline">¶</a></h2>
<p>The top level of the LiSE world model, the Character.</p>
<p>Based on NetworkX DiGraph objects with various additions and
conveniences.</p>
<p>A Character is a graph that follows rules. Its rules may be assigned
to run on only some portion of it: just edges (called Portals), just
nodes, or just nodes of the kind that have a location in another node
(called Places and Things, respectively). Each Character has a
<code class="docutils literal notranslate"><span class="pre">stat</span></code> property that acts very much like a dictionary, in which you
can store game-relevant data for the rules to use.</p>
<p>You can designate some nodes in one Character as avatars of another,
and then assign a rule to run on all of a Character’s avatars. This is
useful for the common case where someone in your game has a location
in the physical world (here, a Character, called ‘physical’) but also
has a behavior flowchart, or a skill tree, that isn’t part of the
physical world. In that case the flowchart is the person’s Character,
and their node in the physical world is an avatar of it.</p>
<dl class="py class">
<dt id="LiSE.character.AbstractCharacter">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">AbstractCharacter</code><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter" title="Permalink to this definition">¶</a></dt>
<dd><p>The Character API, with all requisite mappings and graph generators.</p>
<p>Mappings resemble those of a NetworkX digraph:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">thing</span></code> and <code class="docutils literal notranslate"><span class="pre">place</span></code> are subsets of <code class="docutils literal notranslate"><span class="pre">node</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edge</span></code>, <code class="docutils literal notranslate"><span class="pre">adj</span></code>, and <code class="docutils literal notranslate"><span class="pre">succ</span></code> are aliases of <code class="docutils literal notranslate"><span class="pre">portal</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pred</span></code> is an alias to <code class="docutils literal notranslate"><span class="pre">preportal</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stat</span></code> is a dict-like mapping of data that changes over game-time,</p></li>
</ul>
<p>to be used in place of graph attributes</p>
<dl class="py method">
<dt id="LiSE.character.AbstractCharacter.become">
<code class="sig-name descname">become</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">g</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.become"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.become" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase all my nodes and edges. Replace them with a copy of the graph
provided.</p>
<p>Return myself.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.AbstractCharacter.copy_from">
<code class="sig-name descname">copy_from</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">g</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.copy_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.copy_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy all nodes and edges from the given graph into this.</p>
<p>Return myself.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.AbstractCharacter.cull_edges">
<code class="sig-name descname">cull_edges</code><span class="sig-paren">(</span><em class="sig-param">stat</em>, <em class="sig-param">threshold=0.5</em>, <em class="sig-param">comparator=&lt;built-in function ge&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.cull_edges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.cull_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete edges whose stat &gt;= <code class="docutils literal notranslate"><span class="pre">threshold</span></code> (default 0.5).</p>
<p>Optional argument <code class="docutils literal notranslate"><span class="pre">comparator</span></code> will replace &gt;= as the test
for whether to cull. You can use the name of a stored function.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.AbstractCharacter.cull_nodes">
<code class="sig-name descname">cull_nodes</code><span class="sig-paren">(</span><em class="sig-param">stat</em>, <em class="sig-param">threshold=0.5</em>, <em class="sig-param">comparator=&lt;built-in function ge&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.cull_nodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.cull_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete nodes whose stat &gt;= <code class="docutils literal notranslate"><span class="pre">threshold</span></code> (default 0.5).</p>
<p>Optional argument <code class="docutils literal notranslate"><span class="pre">comparator</span></code> will replace &gt;= as the test
for whether to cull. You can use the name of a stored function.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.AbstractCharacter.cull_portals">
<code class="sig-name descname">cull_portals</code><span class="sig-paren">(</span><em class="sig-param">stat</em>, <em class="sig-param">threshold=0.5</em>, <em class="sig-param">comparator=&lt;built-in function ge&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.cull_portals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.cull_portals" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete portals whose stat &gt;= <code class="docutils literal notranslate"><span class="pre">threshold</span></code> (default 0.5).</p>
<p>Optional argument <code class="docutils literal notranslate"><span class="pre">comparator</span></code> will replace &gt;= as the test
for whether to cull. You can use the name of a stored function.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.AbstractCharacter.do">
<code class="sig-name descname">do</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.do"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.do" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the function to myself, and return myself.</p>
<p>Look up the function in the database if needed. Pass it any
arguments given, keyword or positional.</p>
<p>Useful chiefly when chaining.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.AbstractCharacter.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.character.AbstractCharacter.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.AbstractCharacter.perlin">
<code class="sig-name descname">perlin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stat</span><span class="o">=</span><span class="default_value">'perlin'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#AbstractCharacter.perlin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.AbstractCharacter.perlin" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply Perlin noise to my nodes, and return myself.</p>
<p>I’ll try to use the name of the node as its spatial position
for this purpose, or use its stats ‘x’, ‘y’, and ‘z’, or skip
the node if neither are available. z is assumed 0 if not
provided for a node.</p>
<p>Result will be stored in a node stat named ‘perlin’ by default.
Supply the name of another stat to use it instead.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.AbstractCharacter.stat">
<em class="property">property </em><code class="sig-name descname">stat</code><a class="headerlink" href="#LiSE.character.AbstractCharacter.stat" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.CharRuleMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">CharRuleMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">rulebook</span></em>, <em class="sig-param"><span class="n">booktyp</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#CharRuleMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.CharRuleMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Get rules by name, or make new ones by decorator</p>
<p>You can access the rules in this either dictionary-style or as
attributes. This is for convenience if you want to get at a rule’s
decorators, eg. to add an Action to the rule.</p>
<p>Using this as a decorator will create a new rule, named for the
decorated function, and using the decorated function as the
initial Action.</p>
<p>Using this like a dictionary will let you create new rules,
appending them onto the underlying <code class="xref py py-class docutils literal notranslate"><span class="pre">RuleBook</span></code>; replace one
rule with another, where the new one will have the same index in
the <code class="xref py py-class docutils literal notranslate"><span class="pre">RuleBook</span></code> as the old one; and activate or deactivate
rules. The name of a rule may be used in place of the actual rule,
so long as the rule already exists.</p>
<p>You can also set a rule active or inactive by setting it to
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>, respectively. Inactive rules are still in
the rulebook, but won’t be followed.</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.character.Character">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">Character</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">db</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character" title="Permalink to this definition">¶</a></dt>
<dd><p>A digraph that follows game rules and has a containment hierarchy</p>
<p>Nodes in a Character are subcategorized into Things and
Places. Things have locations, and those locations may be Places
or other Things. To get at those, use the <cite>thing</cite> and <cite>place</cite>
mappings – but in situations where the distinction does not matter,
you may simply address the Character as a mapping, as in NetworkX.</p>
<p>Characters may have avatars in other Characters. These are just
nodes. You can apply rules to a Character’s avatars, and thus to
any collection of nodes you want, perhaps in many different
Characters. The <cite>avatar</cite> attribute handles this. It is a mapping,
keyed by the other Character’s name, then by the name of the node
that is this Character’s avatar. In the common case where a
Character has exactly one avatar, it may be retrieved as
<cite>avatar.only</cite>. When it has more than one avatar, but only has
any avatars in a single other Character, you can get the mapping
of avatars in that Character as <cite>avatar.node</cite>. Add avatars with the
<cite>add_avatar</cite> method and remove them with <cite>del_avatar</cite>.</p>
<p>You can assign rules to Characters with their <cite>rule</cite> attribute,
typically using it as a decorator (see the documentation for
the <cite>rule</cite> module). You can do the same to some of Character’s
attributes:</p>
<ul class="simple">
<li><p><cite>thing.rule</cite> to make a rule run on all Things in this Character
every turn</p></li>
<li><p><cite>place.rule</cite> to make a rule run on all Places in this Character
every turn</p></li>
<li><p><cite>node.rule</cite> to make a rule run on all Things and Places in this
Character every turn</p></li>
<li><p><cite>avatar.rule</cite> to make a rule run on all the avatars this
Character has every turn, regardless of what Character the
avatar is in</p></li>
<li><p><cite>adj.rule</cite> to make a rule run on all the edges this Character
has every turn</p></li>
</ul>
<dl class="py class">
<dt id="LiSE.character.Character.AvatarGraphMapping">
<em class="property">class </em><code class="sig-name descname">AvatarGraphMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">char</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.AvatarGraphMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping of other characters in which one has an avatar.</p>
<p>Maps to a mapping of the avatars themselves, unless there’s
only one other character you have avatars in, in which case
this maps to those.</p>
<p>If you have only one avatar anywhere, you can pretend this
is that entity.</p>
<dl class="py class">
<dt id="LiSE.character.Character.AvatarGraphMapping.CharacterAvatarMapping">
<em class="property">class </em><code class="sig-name descname">CharacterAvatarMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">outer</span></em>, <em class="sig-param"><span class="n">graphn</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.AvatarGraphMapping.CharacterAvatarMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping.CharacterAvatarMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of avatars of one Character in another Character.</p>
<dl class="py method">
<dt id="LiSE.character.Character.AvatarGraphMapping.CharacterAvatarMapping.only">
<em class="property">property </em><code class="sig-name descname">only</code><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping.CharacterAvatarMapping.only" title="Permalink to this definition">¶</a></dt>
<dd><p>If I have only one avatar, return it; else error</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.AvatarGraphMapping.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.AvatarGraphMapping.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.AvatarGraphMapping.node">
<em class="property">property </em><code class="sig-name descname">node</code><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping.node" title="Permalink to this definition">¶</a></dt>
<dd><p>If I have avatars in only one graph, return a map of them</p>
<p>Otherwise, raise AttributeError.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.AvatarGraphMapping.only">
<em class="property">property </em><code class="sig-name descname">only</code><a class="headerlink" href="#LiSE.character.Character.AvatarGraphMapping.only" title="Permalink to this definition">¶</a></dt>
<dd><p>If I have only one avatar, return it</p>
<p>Otherwise, raise AttributeError.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.Character.PlaceMapping">
<em class="property">class </em><code class="sig-name descname">PlaceMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PlaceMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PlaceMapping" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> objects that are in a <a class="reference internal" href="#LiSE.character.Character" title="LiSE.character.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></a></p>
<dl class="py method">
<dt id="LiSE.character.Character.PlaceMapping.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">E</em>, <span class="optional">]</span><em class="sig-param">**F</em><span class="sig-paren">)</span> &#x2192; None.  Update D from mapping/iterable E and F.<a class="reference internal" href="../_modules/LiSE/character.html#Character.PlaceMapping.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PlaceMapping.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.Character.PortalPredecessorsMapping">
<em class="property">class </em><code class="sig-name descname">PortalPredecessorsMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PortalPredecessorsMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PortalPredecessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of nodes that have at least one incoming edge.</p>
<p>Maps to another mapping keyed by the origin nodes, which maps to
Portal objects.</p>
<dl class="py class">
<dt id="LiSE.character.Character.PortalPredecessorsMapping.Predecessors">
<em class="property">class </em><code class="sig-name descname">Predecessors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">dest</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PortalPredecessorsMapping.Predecessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PortalPredecessorsMapping.Predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of possible origins from some destination.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.Character.PortalSuccessorsMapping">
<em class="property">class </em><code class="sig-name descname">PortalSuccessorsMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PortalSuccessorsMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping of nodes that have at least one outgoing edge.</p>
<p>Maps them to another mapping, keyed by the destination nodes,
which maps to Portal objects.</p>
<dl class="py class">
<dt id="LiSE.character.Character.PortalSuccessorsMapping.Successors">
<em class="property">class </em><code class="sig-name descname">Successors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">orig</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PortalSuccessorsMapping.Successors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping.Successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping for possible destinations from some node.</p>
<dl class="py method">
<dt id="LiSE.character.Character.PortalSuccessorsMapping.Successors.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping.Successors.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.PortalSuccessorsMapping.Successors.send">
<em class="property">static </em><code class="sig-name descname">send</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PortalSuccessorsMapping.Successors.send"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping.Successors.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Call all listeners to <code class="docutils literal notranslate"><span class="pre">dest</span></code> and to my <code class="docutils literal notranslate"><span class="pre">orig</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.PortalSuccessorsMapping.Successors.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">E</em>, <span class="optional">]</span><em class="sig-param">**F</em><span class="sig-paren">)</span> &#x2192; None.  Update D from mapping/iterable E and F.<a class="reference internal" href="../_modules/LiSE/character.html#Character.PortalSuccessorsMapping.Successors.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping.Successors.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.PortalSuccessorsMapping.character">
<em class="property">property </em><code class="sig-name descname">character</code><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.PortalSuccessorsMapping.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.PortalSuccessorsMapping.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.PortalSuccessorsMapping.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.PortalSuccessorsMapping.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively update the stats of all portals</p>
<p>Input should be a dictionary of dictionaries of dictionaries
–just like networkx <code class="docutils literal notranslate"><span class="pre">DiGraph._edge</span></code>.</p>
<p>This will create portals as needed, but will only delete
them if you set their value to <code class="docutils literal notranslate"><span class="pre">None</span></code>. Likewise, stats
not specified in the input will be left untouched, if they
are already present, but you can set them to <code class="docutils literal notranslate"><span class="pre">None</span></code> to
delete them.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.Character.ThingMapping">
<em class="property">class </em><code class="sig-name descname">ThingMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.ThingMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.ThingMapping" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Thing</span></code> objects that are in a <a class="reference internal" href="#LiSE.character.Character" title="LiSE.character.Character"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code></a></p>
<dl class="py method">
<dt id="LiSE.character.Character.ThingMapping.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.character.Character.ThingMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.ThingMapping.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#LiSE.character.Character.ThingMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.Character.ThingPlaceMapping">
<em class="property">class </em><code class="sig-name descname">ThingPlaceMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.ThingPlaceMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.ThingPlaceMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>GraphNodeMapping but for Place and Thing</p>
<dl class="py method">
<dt id="LiSE.character.Character.ThingPlaceMapping.character">
<em class="property">property </em><code class="sig-name descname">character</code><a class="headerlink" href="#LiSE.character.Character.ThingPlaceMapping.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.ThingPlaceMapping.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.character.Character.ThingPlaceMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.ThingPlaceMapping.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#LiSE.character.Character.ThingPlaceMapping.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.add_avatar">
<code class="sig-name descname">add_avatar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.add_avatar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.add_avatar" title="Permalink to this definition">¶</a></dt>
<dd><p>Start keeping track of an avatar</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.add_places_from">
<code class="sig-name descname">add_places_from</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">attrs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.add_places_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.add_places_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a series of place names and add the lot.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.add_portal">
<code class="sig-name descname">add_portal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">origin</span></em>, <em class="sig-param"><span class="n">destination</span></em>, <em class="sig-param"><span class="n">symmetrical</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.add_portal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.add_portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect the origin to the destination with a <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>.</p>
<p>Keyword arguments are the <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>’s
attributes. Exception: if keyword <code class="docutils literal notranslate"><span class="pre">symmetrical</span></code> == <code class="docutils literal notranslate"><span class="pre">True</span></code>,
a mirror-<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> will be placed in the opposite
direction between the same nodes. It will always appear to
have the placed <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>’s stats, and any change to the
mirror <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>’s stats will affect the placed
<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.add_portals_from">
<code class="sig-name descname">add_portals_from</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="n">symmetrical</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.add_portals_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.add_portals_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Make portals for a sequence of (origin, destination) pairs</p>
<p>Actually, triples are acceptable too, in which case the third
item is a dictionary of stats for the new <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>.</p>
<p>If optional argument <code class="docutils literal notranslate"><span class="pre">symmetrical</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, all
the <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> instances will have a mirror portal going
in the opposite direction, which will always have the same
stats.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.add_thing">
<code class="sig-name descname">add_thing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">location</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.add_thing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.add_thing" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a new Thing and set its location</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.character.Character.adj_cls">
<code class="sig-name descname">adj_cls</code><a class="headerlink" href="#LiSE.character.Character.adj_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.Character.PortalSuccessorsMapping" title="LiSE.character.Character.PortalSuccessorsMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character.PortalSuccessorsMapping</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.avatars">
<code class="sig-name descname">avatars</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.avatars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.avatars" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all my avatars</p>
<p>Regardless of what character they are in.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.historical">
<code class="sig-name descname">historical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stat</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.historical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.historical" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a historical view on the given stat</p>
<p>This functions like the value of the stat, but changes
when you time travel. Comparisons performed on the
historical view can be passed to <code class="docutils literal notranslate"><span class="pre">engine.turns_when</span></code>
to find out when the comparison held true.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.character.Character.node_map_cls">
<code class="sig-name descname">node_map_cls</code><a class="headerlink" href="#LiSE.character.Character.node_map_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.Character.ThingPlaceMapping" title="LiSE.character.Character.ThingPlaceMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character.ThingPlaceMapping</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.place2thing">
<code class="sig-name descname">place2thing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">location</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.place2thing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.place2thing" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a Place into a Thing with the given location.</p>
<p>It will keep all its attached Portals.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.portals">
<code class="sig-name descname">portals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.portals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.portals" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all portals.</p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.character.Character.pred_cls">
<code class="sig-name descname">pred_cls</code><a class="headerlink" href="#LiSE.character.Character.pred_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.Character.PortalPredecessorsMapping" title="LiSE.character.Character.PortalPredecessorsMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Character.PortalPredecessorsMapping</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.remove_avatar">
<code class="sig-name descname">remove_avatar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.remove_avatar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.remove_avatar" title="Permalink to this definition">¶</a></dt>
<dd><p>This is no longer my avatar, though it still exists</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.remove_portal">
<em class="property">property </em><code class="sig-name descname">remove_portal</code><a class="headerlink" href="#LiSE.character.Character.remove_portal" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Character.thing2place">
<code class="sig-name descname">thing2place</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Character.thing2place"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Character.thing2place" title="Permalink to this definition">¶</a></dt>
<dd><p>Unset a Thing’s location, and thus turn it into a Place.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.Facade">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">Facade</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py class">
<dt id="LiSE.character.Facade.PlaceMapping">
<em class="property">class </em><code class="sig-name descname">PlaceMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">facade</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.PlaceMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.PlaceMapping" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt id="LiSE.character.Facade.PlaceMapping.facadecls">
<code class="sig-name descname">facadecls</code><a class="headerlink" href="#LiSE.character.Facade.PlaceMapping.facadecls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.FacadePlace" title="LiSE.character.FacadePlace"><code class="xref py py-class docutils literal notranslate"><span class="pre">FacadePlace</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.character.Facade.PlaceMapping.innercls">
<code class="sig-name descname">innercls</code><a class="headerlink" href="#LiSE.character.Facade.PlaceMapping.innercls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.place.Place" title="LiSE.place.Place"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.place.Place</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.Facade.PortalPredecessorsMapping">
<em class="property">class </em><code class="sig-name descname">PortalPredecessorsMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">facade</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.PortalPredecessorsMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.PortalPredecessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt id="LiSE.character.Facade.PortalPredecessorsMapping.cls">
<code class="sig-name descname">cls</code><a class="headerlink" href="#LiSE.character.Facade.PortalPredecessorsMapping.cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.FacadePortalPredecessors" title="LiSE.character.FacadePortalPredecessors"><code class="xref py py-class docutils literal notranslate"><span class="pre">FacadePortalPredecessors</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.Facade.PortalSuccessorsMapping">
<em class="property">class </em><code class="sig-name descname">PortalSuccessorsMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">facade</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.PortalSuccessorsMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.PortalSuccessorsMapping" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt id="LiSE.character.Facade.PortalSuccessorsMapping.cls">
<code class="sig-name descname">cls</code><a class="headerlink" href="#LiSE.character.Facade.PortalSuccessorsMapping.cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.FacadePortalSuccessors" title="LiSE.character.FacadePortalSuccessors"><code class="xref py py-class docutils literal notranslate"><span class="pre">FacadePortalSuccessors</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.Facade.StatMapping">
<em class="property">class </em><code class="sig-name descname">StatMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">facade</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.StatMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.StatMapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.character.Facade.ThingMapping">
<em class="property">class </em><code class="sig-name descname">ThingMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">facade</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.ThingMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.ThingMapping" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt id="LiSE.character.Facade.ThingMapping.facadecls">
<code class="sig-name descname">facadecls</code><a class="headerlink" href="#LiSE.character.Facade.ThingMapping.facadecls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.FacadeThing" title="LiSE.character.FacadeThing"><code class="xref py py-class docutils literal notranslate"><span class="pre">FacadeThing</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.character.Facade.ThingMapping.innercls">
<code class="sig-name descname">innercls</code><a class="headerlink" href="#LiSE.character.Facade.ThingMapping.innercls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.thing.Thing" title="LiSE.thing.Thing"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.thing.Thing</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Facade.add_edge">
<code class="sig-name descname">add_edge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.add_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an edge between u and v.</p>
<p>The nodes u and v will be automatically added if they are
not already in the graph.</p>
<p>Edge attributes can be specified with keywords or by directly
accessing the edge’s attribute dictionary. See examples below.</p>
<dl class="simple">
<dt>u, v<span class="classifier">nodes</span></dt><dd><p>Nodes can be, for example, strings or numbers.
Nodes must be hashable (and not None) Python objects.</p>
</dd>
<dt>attr<span class="classifier">keyword arguments, optional</span></dt><dd><p>Edge data (or labels or objects) can be assigned using
keyword arguments.</p>
</dd>
</dl>
<p>add_edges_from : add a collection of edges</p>
<p>Adding an edge that already exists updates the edge data.</p>
<p>Many NetworkX algorithms designed for weighted graphs use
an edge attribute (by default <cite>weight</cite>) to hold a numerical value.</p>
<p>The following all add the edge e=(1, 2) to graph G:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>   <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>           <span class="c1"># explicit two-node form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>             <span class="c1"># single edge as tuple of two nodes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span> <span class="p">)</span> <span class="c1"># add edges from iterable container</span>
</pre></div>
</div>
<p>Associate data to edges using keywords:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">342.7</span><span class="p">)</span>
</pre></div>
</div>
<p>For non-string attribute keys, use subscript notation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Facade.add_node">
<code class="sig-name descname">add_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.add_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.add_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single node <cite>node_for_adding</cite> and update node attributes.</p>
<dl class="simple">
<dt>node_for_adding<span class="classifier">node</span></dt><dd><p>A node can be any hashable Python object except None.</p>
</dd>
<dt>attr<span class="classifier">keyword arguments, optional</span></dt><dd><p>Set or change node attributes using key=value.</p>
</dd>
</dl>
<p>add_nodes_from</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>   <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K3</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">K3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Use keywords set/change node attributes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">UTM</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;13S&#39;</span><span class="p">,</span> <span class="mi">382871</span><span class="p">,</span> <span class="mi">3972649</span><span class="p">))</span>
</pre></div>
</div>
<p>A hashable object is one that can be used as a key in a Python
dictionary. This includes strings, numbers, tuples of strings
and numbers, etc.</p>
<p>On many platforms hashable items also include mutables such as
NetworkX Graphs, though one should be careful that the hash
doesn’t change on mutables.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Facade.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.character.Facade.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.character.Facade.remove_node">
<code class="sig-name descname">remove_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#Facade.remove_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.Facade.remove_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove node n.</p>
<p>Removes the node n and all adjacent edges.
Attempting to remove a non-existent node will raise an exception.</p>
<dl class="simple">
<dt>n<span class="classifier">node</span></dt><dd><p>A node in the graph</p>
</dd>
</dl>
<dl class="simple">
<dt>NetworkXError</dt><dd><p>If n is not in the graph.</p>
</dd>
</dl>
<p>remove_nodes_from</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.FacadeEntity">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">FacadeEntity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapping</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadeEntity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadeEntity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.character.FacadeEntityMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">FacadeEntityMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">facade</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadeEntityMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadeEntityMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping that contains entities in a Facade.</p>
<p>All the entities are of the same type, <code class="docutils literal notranslate"><span class="pre">facadecls</span></code>, possibly
being distorted views of entities of the type <code class="docutils literal notranslate"><span class="pre">innercls</span></code>.</p>
<dl class="py method">
<dt id="LiSE.character.FacadeEntityMapping.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.character.FacadeEntityMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.FacadeNode">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">FacadeNode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapping</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadeNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadeNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.character.FacadePlace">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">FacadePlace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapping</span></em>, <em class="sig-param"><span class="n">real_or_name</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadePlace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadePlace" title="Permalink to this definition">¶</a></dt>
<dd><p>Lightweight analogue of Place for Facade use.</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.character.FacadePortal">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">FacadePortal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapping</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadePortal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadePortal" title="Permalink to this definition">¶</a></dt>
<dd><p>Lightweight analogue of Portal for Facade use.</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.character.FacadePortalMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">FacadePortalMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">facade</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadePortalMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadePortalMapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.character.FacadePortalPredecessors">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">FacadePortalPredecessors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">facade</span></em>, <em class="sig-param"><span class="n">destname</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadePortalPredecessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadePortalPredecessors" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt id="LiSE.character.FacadePortalPredecessors.facadecls">
<code class="sig-name descname">facadecls</code><a class="headerlink" href="#LiSE.character.FacadePortalPredecessors.facadecls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.FacadePortal" title="LiSE.character.FacadePortal"><code class="xref py py-class docutils literal notranslate"><span class="pre">FacadePortal</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.character.FacadePortalPredecessors.innercls">
<code class="sig-name descname">innercls</code><a class="headerlink" href="#LiSE.character.FacadePortalPredecessors.innercls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.portal.Portal" title="LiSE.portal.Portal"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.portal.Portal</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.FacadePortalSuccessors">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">FacadePortalSuccessors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">facade</span></em>, <em class="sig-param"><span class="n">origname</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadePortalSuccessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadePortalSuccessors" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt id="LiSE.character.FacadePortalSuccessors.facadecls">
<code class="sig-name descname">facadecls</code><a class="headerlink" href="#LiSE.character.FacadePortalSuccessors.facadecls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.character.FacadePortal" title="LiSE.character.FacadePortal"><code class="xref py py-class docutils literal notranslate"><span class="pre">FacadePortal</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt id="LiSE.character.FacadePortalSuccessors.innercls">
<code class="sig-name descname">innercls</code><a class="headerlink" href="#LiSE.character.FacadePortalSuccessors.innercls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.portal.Portal" title="LiSE.portal.Portal"><code class="xref py py-class docutils literal notranslate"><span class="pre">LiSE.portal.Portal</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.character.FacadeThing">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">FacadeThing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mapping</span></em>, <em class="sig-param"><span class="n">real_or_name</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#FacadeThing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.FacadeThing" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.character.RuleFollower">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">RuleFollower</code><a class="reference internal" href="../_modules/LiSE/character.html#RuleFollower"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.RuleFollower" title="Permalink to this definition">¶</a></dt>
<dd><p>Mixin class. Has a rulebook, which you can get a RuleMapping into.</p>
</dd></dl>

<dl class="py function">
<dt id="LiSE.character.grid_2d_8graph">
<code class="sig-prename descclassname">LiSE.character.</code><code class="sig-name descname">grid_2d_8graph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/character.html#grid_2d_8graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.character.grid_2d_8graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a 2d graph that’s connected 8 ways, with diagonals</p>
</dd></dl>

</div>
<div class="section" id="module-LiSE.node">
<span id="node"></span><h2>node<a class="headerlink" href="#module-LiSE.node" title="Permalink to this headline">¶</a></h2>
<p>A base class for nodes that can be in a character.</p>
<p>Every actual node that you’re meant to use will be a place or
thing. This module is for what they have in common.</p>
<dl class="py class">
<dt id="LiSE.node.Node">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.node.</code><code class="sig-name descname">Node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>The fundamental graph component, which edges (in LiSE, “portals”)
go between.</p>
<p>Every LiSE node is either a thing or a place. They share in common
the abilities to follow rules; to be connected by portals; and to
contain things.</p>
<dl class="py method">
<dt id="LiSE.node.Node.adj">
<em class="property">property </em><code class="sig-name descname">adj</code><a class="headerlink" href="#LiSE.node.Node.adj" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.character">
<em class="property">property </em><code class="sig-name descname">character</code><a class="headerlink" href="#LiSE.node.Node.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete everything</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Get rid of this, starting now.</p>
<p>Apart from deleting the node, this also informs all its users
that it doesn’t exist and therefore can’t be their avatar
anymore.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.edge">
<em class="property">property </em><code class="sig-name descname">edge</code><a class="headerlink" href="#LiSE.node.Node.edge" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.node.Node.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.historical">
<code class="sig-name descname">historical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stat</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.historical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.historical" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a reference to the values that a stat has had in the past.</p>
<p>You can use the reference in comparisons to make a history
query, and execute the query by calling it, or passing it to
<code class="docutils literal notranslate"><span class="pre">self.engine.ticks_when</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#LiSE.node.Node.name" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.new_thing">
<code class="sig-name descname">new_thing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">stats</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.new_thing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.new_thing" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new thing, located here, and return it.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.one_way">
<code class="sig-name descname">one_way</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">stats</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.one_way"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.one_way" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect a portal from here to another node, and return it.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.one_way_portal">
<code class="sig-name descname">one_way_portal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">stats</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.one_way_portal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.one_way_portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect a portal from here to another node, and return it.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.path_exists">
<code class="sig-name descname">path_exists</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.path_exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.path_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether there is a path leading from me to <code class="docutils literal notranslate"><span class="pre">dest</span></code>.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">weight</span></code>, only consider edges that have a stat by the
given name.</p>
<p>Raise <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> if <code class="docutils literal notranslate"><span class="pre">dest</span></code> is not a node in my character
or the name of one.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.portals">
<code class="sig-name descname">portals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.portals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.portals" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> objects that lead away from me</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.pred">
<em class="property">property </em><code class="sig-name descname">pred</code><a class="headerlink" href="#LiSE.node.Node.pred" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.predecessor">
<em class="property">property </em><code class="sig-name descname">predecessor</code><a class="headerlink" href="#LiSE.node.Node.predecessor" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.predecessors">
<code class="sig-name descname">predecessors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.predecessors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over nodes with edges leading here from there.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.preportals">
<code class="sig-name descname">preportals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.preportals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.preportals" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> objects that lead to me</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.shortest_path">
<code class="sig-name descname">shortest_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.shortest_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.shortest_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of node names leading from me to <code class="docutils literal notranslate"><span class="pre">dest</span></code>.</p>
<p>Raise <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> if <code class="docutils literal notranslate"><span class="pre">dest</span></code> is not a node in my character
or the name of one.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.shortest_path_length">
<code class="sig-name descname">shortest_path_length</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.shortest_path_length"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.shortest_path_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the path from me to <code class="docutils literal notranslate"><span class="pre">dest</span></code>.</p>
<p>Raise <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> if <code class="docutils literal notranslate"><span class="pre">dest</span></code> is not a node in my character
or the name of one.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.successor">
<em class="property">property </em><code class="sig-name descname">successor</code><a class="headerlink" href="#LiSE.node.Node.successor" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.successors">
<code class="sig-name descname">successors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.successors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over nodes with edges leading from here to there.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.two_way">
<code class="sig-name descname">two_way</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">stats</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.two_way"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.two_way" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect these nodes with a two-way portal and return it.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.node.Node.two_way_portal">
<code class="sig-name descname">two_way_portal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">stats</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#Node.two_way_portal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.Node.two_way_portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect these nodes with a two-way portal and return it.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.node.UserDescriptor">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.node.</code><code class="sig-name descname">UserDescriptor</code><a class="reference internal" href="../_modules/LiSE/node.html#UserDescriptor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.UserDescriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a node’s user if there’s only one</p>
<p>If there are many users, but one of them has the same name as this node, give that one.</p>
<p>Otherwise, raise AmbiguousUserError.</p>
<dl class="py attribute">
<dt id="LiSE.node.UserDescriptor.usermapping">
<code class="sig-name descname">usermapping</code><a class="headerlink" href="#LiSE.node.UserDescriptor.usermapping" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#LiSE.node.UserMapping" title="LiSE.node.UserMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">UserMapping</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.node.UserMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.node.</code><code class="sig-name descname">UserMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/node.html#UserMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.node.UserMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping of the characters that have a particular node as an avatar.</p>
<p>Getting characters from here isn’t any better than getting them from
the engine direct, but with this you can do things like use the
.get() method to get a character if it’s a user and otherwise
get something else; or test whether the character’s name is in
the keys; and so on.</p>
<dl class="py method">
<dt id="LiSE.node.UserMapping.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.node.UserMapping.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-LiSE.place">
<span id="place"></span><h2>place<a class="headerlink" href="#module-LiSE.place" title="Permalink to this headline">¶</a></h2>
<p>The type of node that is a location.</p>
<p>Though both things and places are nodes, things are obliged to be
located in another node. Places are not.</p>
<dl class="py class">
<dt id="LiSE.place.Place">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.place.</code><code class="sig-name descname">Place</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/place.html#Place"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.place.Place" title="Permalink to this definition">¶</a></dt>
<dd><p>The kind of node where a thing might ultimately be located.</p>
<dl class="py method">
<dt id="LiSE.place.Place.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/place.html#Place.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.place.Place.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove myself from the world model immediately.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-LiSE.thing">
<span id="thing"></span><h2>thing<a class="headerlink" href="#module-LiSE.thing" title="Permalink to this headline">¶</a></h2>
<p>The sort of node that is ultimately located in a Place.</p>
<p>Things may be located in other Things as well, but eventually must be
recursively located in a Place.</p>
<p>There’s a subtle distinction between “location” and “containment”: a
Thing may be contained by a Portal, but cannot be located there –
only in one of the Portal’s endpoints. Things are both located in and
contained by Places, or possibly other Things.</p>
<dl class="py class">
<dt id="LiSE.thing.Thing">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.thing.</code><code class="sig-name descname">Thing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/thing.html#Thing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.thing.Thing" title="Permalink to this definition">¶</a></dt>
<dd><p>The sort of item that has a particular location at any given time.</p>
<p>If a Thing is in a Place, it is standing still. If it is in a
Portal, it is moving through that Portal however fast it must in
order to arrive at the other end when it is scheduled to. If it is
in another Thing, then it is wherever that is, and moving the
same.</p>
<dl class="py method">
<dt id="LiSE.thing.Thing.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/thing.html#Thing.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.thing.Thing.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Unset everything.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.thing.Thing.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/thing.html#Thing.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.thing.Thing.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Get rid of this, starting now.</p>
<p>Apart from deleting the node, this also informs all its users
that it doesn’t exist and therefore can’t be their avatar
anymore.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.thing.Thing.follow_path">
<code class="sig-name descname">follow_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/thing.html#Thing.follow_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.thing.Thing.follow_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Go to several <code class="xref py py-class docutils literal notranslate"><span class="pre">Place`s</span> <span class="pre">in</span> <span class="pre">succession,</span> <span class="pre">deciding</span> <span class="pre">how</span> <span class="pre">long</span> <span class="pre">to</span>
<span class="pre">spend</span> <span class="pre">in</span> <span class="pre">each</span> <span class="pre">by</span> <span class="pre">consulting</span> <span class="pre">the</span> <span class="pre">``weight`</span></code> stat of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> connecting the one <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> to the next.</p>
<p>Return the total number of turns the travel will take. Raise
<code class="xref py py-class docutils literal notranslate"><span class="pre">TravelException</span></code> if I can’t follow the whole path,
either because some of its nodes don’t exist, or because I’m
scheduled to be somewhere else.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.thing.Thing.go_to_place">
<code class="sig-name descname">go_to_place</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">place</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/thing.html#Thing.go_to_place"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.thing.Thing.go_to_place" title="Permalink to this definition">¶</a></dt>
<dd><p>Assuming I’m in a <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> that has a <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code> direct
to the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code>, schedule myself to travel to the
given <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code>, taking an amount of time indicated by
the <code class="docutils literal notranslate"><span class="pre">weight</span></code> stat on the <code class="xref py py-class docutils literal notranslate"><span class="pre">Portal</span></code>, if given; else 1
turn.</p>
<p>Return the number of turns the travel will take.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.thing.Thing.location">
<em class="property">property </em><code class="sig-name descname">location</code><a class="headerlink" href="#LiSE.thing.Thing.location" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">Thing</span></code> or <code class="docutils literal notranslate"><span class="pre">Place</span></code> I’m in.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.thing.Thing.travel_to">
<code class="sig-name descname">travel_to</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">weight</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">graph</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/thing.html#Thing.travel_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.thing.Thing.travel_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the shortest path to the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Place</span></code> from where I am
now, and follow it.</p>
<p>If supplied, the <code class="docutils literal notranslate"><span class="pre">weight</span></code> stat of the :class:<a href="#id3"><span class="problematic" id="id4">`</span></a>Portal`s along
the path will be used in pathfinding, and for deciding how
long to stay in each Place along the way.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">graph</span></code> argument may be any NetworkX-style graph. It
will be used for pathfinding if supplied, otherwise I’ll use
my <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>. In either case, however, I will attempt
to actually follow the path using my <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>, which
might not be possible if the supplied <code class="docutils literal notranslate"><span class="pre">graph</span></code> and my
<code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code> are too different. If it’s not possible,
I’ll raise a <code class="xref py py-class docutils literal notranslate"><span class="pre">TravelException</span></code>, whose <code class="docutils literal notranslate"><span class="pre">subpath</span></code>
attribute holds the part of the path that I <em>can</em> follow. To
make me follow it, pass it to my <code class="docutils literal notranslate"><span class="pre">follow_path</span></code> method.</p>
<p>Return value is the number of turns the travel will take.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-LiSE.portal">
<span id="portal"></span><h2>portal<a class="headerlink" href="#module-LiSE.portal" title="Permalink to this headline">¶</a></h2>
<p>Directed edges, as used by LiSE.</p>
<dl class="py class">
<dt id="LiSE.portal.Portal">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.portal.</code><code class="sig-name descname">Portal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">idx</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/portal.html#Portal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.portal.Portal" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection between two Places that Things may travel along.</p>
<p>Portals are one-way, but you can make one appear two-way by
setting the <code class="docutils literal notranslate"><span class="pre">symmetrical</span></code> key to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
eg. <code class="docutils literal notranslate"><span class="pre">character.add_portal(orig,</span> <span class="pre">dest,</span> <span class="pre">symmetrical=True)</span></code>.
The portal going the other way will appear to have all the
stats of this one, and attempting to set a stat on it will
set it here instead.</p>
<dl class="py method">
<dt id="LiSE.portal.Portal.character">
<em class="property">property </em><code class="sig-name descname">character</code><a class="headerlink" href="#LiSE.portal.Portal.character" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.portal.Portal.delete">
<code class="sig-name descname">delete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/portal.html#Portal.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.portal.Portal.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove myself from my <code class="xref py py-class docutils literal notranslate"><span class="pre">Character</span></code>.</p>
<p>For symmetry with <code class="xref py py-class docutils literal notranslate"><span class="pre">Thing</span></code> and :class`Place`.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.portal.Portal.engine">
<em class="property">property </em><code class="sig-name descname">engine</code><a class="headerlink" href="#LiSE.portal.Portal.engine" title="Permalink to this definition">¶</a></dt>
<dd><p>attrgetter(attr, …) –&gt; attrgetter object</p>
<p>Return a callable object that fetches the given attribute(s) from its operand.
After f = attrgetter(‘name’), the call f(r) returns r.name.
After g = attrgetter(‘name’, ‘date’), the call g(r) returns (r.name, r.date).
After h = attrgetter(‘name.first’, ‘name.last’), the call h(r) returns
(r.name.first, r.name.last).</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.portal.Portal.historical">
<code class="sig-name descname">historical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stat</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/portal.html#Portal.historical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.portal.Portal.historical" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a reference to the values that a stat has had in the past.</p>
<p>You can use the reference in comparisons to make a history
query, and execute the query by calling it, or passing it to
<code class="docutils literal notranslate"><span class="pre">self.engine.ticks_when</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.portal.Portal.reciprocal">
<em class="property">property </em><code class="sig-name descname">reciprocal</code><a class="headerlink" href="#LiSE.portal.Portal.reciprocal" title="Permalink to this definition">¶</a></dt>
<dd><p>If there’s another Portal connecting the same origin and
destination that I do, but going the opposite way, return
it. Else raise KeyError.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.portal.Portal.unwrap">
<code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/portal.html#Portal.unwrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.portal.Portal.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of myself as a dict, and unwrap any wrapper objects in me.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.portal.Portal.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/portal.html#Portal.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.portal.Portal.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Works like regular update, but only actually updates when the new
value and the old value differ. This is necessary to prevent
certain infinite loops.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>d</strong> – a dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.portal.RuleMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.portal.</code><code class="sig-name descname">RuleMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">portal</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/portal.html#RuleMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.portal.RuleMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Mapping to get rules followed by a portal.</p>
</dd></dl>

</div>
<div class="section" id="module-LiSE.rule">
<span id="rule"></span><h2>rule<a class="headerlink" href="#module-LiSE.rule" title="Permalink to this headline">¶</a></h2>
<p>The fundamental unit of game logic, the Rule, and structures to
store and organize them in.</p>
<p>A Rule is three lists of functions: triggers, prereqs, and actions.
The actions do something, anything that you need your game to do, but
probably making a specific change to the world model. The triggers and
prereqs between them specify when the action should occur: any of its
triggers can tell it to happen, but then any of its prereqs may stop it
from happening.</p>
<p>Rules are assembled into RuleBooks, essentially just lists of Rules
that can then be assigned to be followed by any game entity –
but each game entity has its own RuleBook by default, and you never
need to change that.</p>
<p>To add a new rule to a LiSE entity, the easiest thing is to use the
decorator syntax:</p>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a>`
&#64;entity.rule
def do_something(entity):</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>&#64;do_something.trigger
def whenever(entity):</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>&#64;do_something.trigger
def forever(entity):</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>&#64;do_something.action
def do_something_else(entity):</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p><a href="#id7"><span class="problematic" id="id8">``</span></a><a href="#id9"><span class="problematic" id="id10">`</span></a></p>
<p>When run, this code will:
* copy the <cite>do_something</cite> function to <cite>action.py</cite>, where LiSE knows</p>
<blockquote>
<div><p>to run it when a rule triggers it</p>
</div></blockquote>
<ul class="simple">
<li><p>create a new rule named <cite>‘do_something’</cite></p></li>
<li><p>set the function <cite>do_something</cite> as the first (and, so far, only) entry
in the actions list of the rule by that name</p></li>
<li><p>copy the <cite>whenever</cite> function to <cite>trigger.py</cite>, where LiSE knows to
call it when a rule has it as a trigger</p></li>
<li><p>set the function <cite>whenever</cite> as the first entry in the triggers list
of the rule <cite>‘do_something’</cite></p></li>
<li><p>append the function <cite>forever</cite> to the same triggers list</p></li>
<li><p>copy <cite>do_something_else</cite> to <cite>action.py</cite></p></li>
<li><p>append <cite>do_something_else</cite> to the actions list of the rule</p></li>
</ul>
<p>The <cite>trigger</cite>, <cite>prereq</cite>, and <cite>action</cite> attributes of Rule objects
may also be used like lists. You can put functions in them yourself,
provided they are already present in the correct module. If it’s
inconvenient to get the actual function object, use a string of
the function’s name.</p>
<dl class="py class">
<dt id="LiSE.rule.ActionList">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.rule.</code><code class="sig-name descname">ActionList</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#ActionList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.ActionList" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of action functions for rules</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.rule.AllRuleBooks">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.rule.</code><code class="sig-name descname">AllRuleBooks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">engine</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#AllRuleBooks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.AllRuleBooks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="LiSE.rule.AllRules">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.rule.</code><code class="sig-name descname">AllRules</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">engine</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#AllRules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.AllRules" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping of every rule in the game.</p>
<p>You can use this as a decorator to make a rule and not assign it
to anything.</p>
<dl class="py method">
<dt id="LiSE.rule.AllRules.new_empty">
<code class="sig-name descname">new_empty</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#AllRules.new_empty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.AllRules.new_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a new rule with no actions or anything, and return it.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.rule.PrereqList">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.rule.</code><code class="sig-name descname">PrereqList</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#PrereqList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.PrereqList" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of prereq functions for rules</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.rule.Rule">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.rule.</code><code class="sig-name descname">Rule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">engine</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">triggers</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">prereqs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">actions</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">create</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#Rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.Rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Stuff that might happen in the simulation under some conditions</p>
<p>Rules are comprised of three lists of functions:</p>
<ul class="simple">
<li><p>actions, which mutate the world state</p></li>
<li><p>triggers, which make the actions happen</p></li>
<li><p>prereqs, which prevent the actions from happening when triggered</p></li>
</ul>
<p>Each kind of function should be stored in the appropriate module
supplied to the LiSE core at startup. This makes it possible to
load the functions on later startups. You may instead use the string
name of a function already stored in the module, or use the
<cite>trigger</cite>, <cite>prereq</cite>, or <cite>action</cite> decorator on a new function to
add it to both the module and the rule.</p>
<dl class="py method">
<dt id="LiSE.rule.Rule.action">
<code class="sig-name descname">action</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#Rule.action"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.Rule.action" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to append the function to my actions list.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.rule.Rule.always">
<code class="sig-name descname">always</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#Rule.always"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.Rule.always" title="Permalink to this definition">¶</a></dt>
<dd><p>Arrange to be triggered every tick, regardless of circumstance.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.rule.Rule.duplicate">
<code class="sig-name descname">duplicate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">newname</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#Rule.duplicate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.Rule.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new rule that’s just like this one, but under a new
name.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.rule.Rule.prereq">
<code class="sig-name descname">prereq</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#Rule.prereq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.Rule.prereq" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to append the function to my prereqs list.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.rule.Rule.trigger">
<code class="sig-name descname">trigger</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#Rule.trigger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.Rule.trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to append the function to my triggers list.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.rule.RuleBook">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.rule.</code><code class="sig-name descname">RuleBook</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">engine</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleBook"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleBook" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of rules to be followed for some Character, or a part of it
anyway.</p>
<dl class="py method">
<dt id="LiSE.rule.RuleBook.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="optional">[</span>, <em class="sig-param">start</em><span class="optional">[</span>, <em class="sig-param">stop</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; integer – return first index of value.<a class="reference internal" href="../_modules/LiSE/rule.html#RuleBook.index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleBook.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises ValueError if the value is not present.</p>
<p>Supporting start and stop arguments is optional, but
recommended.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.rule.RuleBook.insert">
<code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">v</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleBook.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleBook.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>S.insert(index, value) – insert value before index</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.rule.RuleFollower">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.rule.</code><code class="sig-name descname">RuleFollower</code><a class="reference internal" href="../_modules/LiSE/rule.html#RuleFollower"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleFollower" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface for that which has a rulebook associated, which you can
get a <a class="reference internal" href="#LiSE.rule.RuleMapping" title="LiSE.rule.RuleMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleMapping</span></code></a> into</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.rule.RuleFuncList">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.rule.</code><code class="sig-name descname">RuleFuncList</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleFuncList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleFuncList" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract class for lists of functions like trigger, prereq, action</p>
<dl class="py method">
<dt id="LiSE.rule.RuleFuncList.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleFuncList.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleFuncList.append" title="Permalink to this definition">¶</a></dt>
<dd><p>S.append(value) – append value to the end of the sequence</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.rule.RuleFuncList.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="optional">[</span>, <em class="sig-param">start</em><span class="optional">[</span>, <em class="sig-param">stop</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; integer – return first index of value.<a class="reference internal" href="../_modules/LiSE/rule.html#RuleFuncList.index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleFuncList.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises ValueError if the value is not present.</p>
<p>Supporting start and stop arguments is optional, but
recommended.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.rule.RuleFuncList.insert">
<code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">v</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleFuncList.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleFuncList.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>S.insert(index, value) – insert value before index</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="LiSE.rule.RuleFuncListDescriptor">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.rule.</code><code class="sig-name descname">RuleFuncListDescriptor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cls</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleFuncListDescriptor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleFuncListDescriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Descriptor that lets you get and set a whole RuleFuncList at once</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.rule.RuleMapping">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.rule.</code><code class="sig-name descname">RuleMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">engine</span></em>, <em class="sig-param"><span class="n">rulebook</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#RuleMapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.RuleMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps a <a class="reference internal" href="#LiSE.rule.RuleBook" title="LiSE.rule.RuleBook"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleBook</span></code></a> so you can get its rules by name.</p>
<p>You can access the rules in this either dictionary-style or as
attributes. This is for convenience if you want to get at a rule’s
decorators, eg. to add an Action to the rule.</p>
<p>Using this as a decorator will create a new rule, named for the
decorated function, and using the decorated function as the
initial Action.</p>
<p>Using this like a dictionary will let you create new rules,
appending them onto the underlying <a class="reference internal" href="#LiSE.rule.RuleBook" title="LiSE.rule.RuleBook"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleBook</span></code></a>; replace one
rule with another, where the new one will have the same index in
the <a class="reference internal" href="#LiSE.rule.RuleBook" title="LiSE.rule.RuleBook"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleBook</span></code></a> as the old one; and activate or deactivate
rules. The name of a rule may be used in place of the actual rule,
so long as the rule already exists.</p>
</dd></dl>

<dl class="py class">
<dt id="LiSE.rule.TriggerList">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.rule.</code><code class="sig-name descname">TriggerList</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rule</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#TriggerList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.TriggerList" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of trigger functions for rules</p>
</dd></dl>

<dl class="py function">
<dt id="LiSE.rule.roundtrip_dedent">
<code class="sig-prename descclassname">LiSE.rule.</code><code class="sig-name descname">roundtrip_dedent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">source</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/rule.html#roundtrip_dedent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.rule.roundtrip_dedent" title="Permalink to this definition">¶</a></dt>
<dd><p>Reformat some lines of code into what unparse makes.</p>
</dd></dl>

</div>
<div class="section" id="module-LiSE.query">
<span id="query"></span><h2>query<a class="headerlink" href="#module-LiSE.query" title="Permalink to this headline">¶</a></h2>
<p>The query engine provides Pythonic methods to access the database.</p>
<p>This module also contains a notably unfinished implementation of a query
language specific to LiSE. Access some stats using entities’ method
<code class="docutils literal notranslate"><span class="pre">historical</span></code>, and do comparisons on those, and instead of a boolean
result you’ll get a callable object that will return an iterator over
turn numbers in which the comparison evaluated to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="py class">
<dt id="LiSE.query.QueryEngine">
<em class="property">class </em><code class="sig-prename descclassname">LiSE.query.</code><code class="sig-name descname">QueryEngine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dbstring</span></em>, <em class="sig-param"><span class="n">connect_args</span></em>, <em class="sig-param"><span class="n">alchemy</span></em>, <em class="sig-param"><span class="n">pack</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">unpack</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#QueryEngine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.QueryEngine" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="LiSE.query.QueryEngine.exist_edge">
<code class="sig-name descname">exist_edge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">orig</span></em>, <em class="sig-param"><span class="n">dest</span></em>, <em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">extant</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#QueryEngine.exist_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.QueryEngine.exist_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare whether or not this edge exists.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.query.QueryEngine.exist_node">
<code class="sig-name descname">exist_node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">character</span></em>, <em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">branch</span></em>, <em class="sig-param"><span class="n">turn</span></em>, <em class="sig-param"><span class="n">tick</span></em>, <em class="sig-param"><span class="n">extant</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#QueryEngine.exist_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.QueryEngine.exist_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare that the node exists or doesn’t.</p>
<p>Inserts a new record or updates an old one, as needed.</p>
</dd></dl>

<dl class="py method">
<dt id="LiSE.query.QueryEngine.initdb">
<code class="sig-name descname">initdb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#QueryEngine.initdb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.QueryEngine.initdb" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the database schema, both for allegedb and the special
extensions for LiSE</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="LiSE.query.slow_iter_turns_eval_cmp">
<code class="sig-prename descclassname">LiSE.query.</code><code class="sig-name descname">slow_iter_turns_eval_cmp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">qry</span></em>, <em class="sig-param"><span class="n">oper</span></em>, <em class="sig-param"><span class="n">start_branch</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">engine</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#slow_iter_turns_eval_cmp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.slow_iter_turns_eval_cmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all turns on which a comparison holds.</p>
<p>This is expensive. It evaluates the query for every turn in history.</p>
</dd></dl>

<dl class="py function">
<dt id="LiSE.query.windows_intersection">
<code class="sig-prename descclassname">LiSE.query.</code><code class="sig-name descname">windows_intersection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">windows</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#windows_intersection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.windows_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of (beginning, ending), return another describing where they overlap.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="LiSE.query.windows_union">
<code class="sig-prename descclassname">LiSE.query.</code><code class="sig-name descname">windows_union</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">windows</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/LiSE/query.html#windows_union"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#LiSE.query.windows_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of (beginning, ending), return a minimal version that contains the same ranges.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)">list</a></p>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">LiSE</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../manual.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manual.html#ide">IDE</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">LiSE</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#world-modelling">World Modelling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rule-creation">Rule Creation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#time-control">Time Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="#input-prompts">Input Prompts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.engine">engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.character">character</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.node">node</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.place">place</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.thing">thing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.portal">portal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.rule">rule</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-LiSE.query">query</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ELiDE/index.html">ELiDE</a></li>
<li class="toctree-l1"><a class="reference internal" href="LiSE/allegedb/index.html">allegedb</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../manual.html" title="previous chapter">Introduction</a></li>
      <li>Next: <a href="../ELiDE/index.html" title="next chapter">ELiDE</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;Zachary Spector.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/LiSE/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>